
<!DOCTYPE html>
<!-- <p style="text-align: center; font-style: italic; color: #555;">Content coming soon!</p>-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Content C Programming Series - The Coders Club</title>
    <link rel="icon" href="TCC.png" type="image/png">
    <link rel="stylesheet" href="styles.css"> 
    <style>
       /* General Container for all content */
    .content-container-wrapper {
    width: 90%;
    max-width: 900px; /* Increased max-width for better content display */
    margin-top: 20px;
    margin-right: auto;
    margin-bottom: 70px;
    margin-left: auto; /* General top/bottom margin */
    background: white;
    border-radius: 12px;
    box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
    padding: 15px;
    text-align: center;
    margin-bottom: 70px; /* Space before footer */
}

/* Main Tab Navigation (Week 1, Week 2, etc.) */
.main-tab-nav {
    display: flex;
    justify-content: center;
    background: #E0E0E0;
    border-radius: 8px;
    overflow: hidden;
    padding: 5px;
    box-shadow: inset 0px 2px 6px rgba(0, 0, 0, 0.2);
    margin-bottom: 10px;
    flex-wrap: wrap; /* Added for responsiveness: allows buttons to wrap */
}

/* Nested Tab Navigation (Monday, Tuesday, etc.) */
.nested-tab-nav {
    display: flex;
    justify-content: center;
    background: #e3f2fd; /* Lighter blue background for nested tabs */
    border-radius: 6px;
    overflow: hidden; /* Ensures content within bounds */
    padding: 5px;
    box-shadow: inset 0px 2px 4px rgba(0, 0, 0, 0.1);
    margin-top: 15px; /* Space above nested tabs */
    margin-bottom: 15px; /* Space below nested tabs */
    /* Removed flex-wrap: wrap; to ensure all buttons stay in one row */
}

/* General Tab Button Styling */
.tab-button {
    flex: 1; /* Allows buttons to grow and shrink */
    min-width: 60px; /* Reduced minimum width to allow more buttons in a row */
    padding: 5px 8px; /* Reduced padding to make buttons more compact */
    border: none;
    cursor: pointer;
    background: linear-gradient(to right, #F5F5F5, #E0E0E0);
    color: #333;
    font-size: 14px;
    border-radius: 6px; /* Uniform rounded corners */
    transition: 0.3s;
    box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
    margin: 2px; /* Adjusted margin for consistent spacing */
    /* Removed white-space: nowrap; text-overflow: ellipsis; overflow: hidden; */
    word-break: break-word; /* Allows long words to break and wrap to the next line */
}
.tab-button:hover {
    background: #1E88E5;
    color: white;
}

.tab-button.active {
    background: #00408f;
    color: white;
    font-weight: bold;
    box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.3);
}

/* Styling for disabled buttons */
.tab-button.disabled {
    background: #cccccc;
    color: #666666;
    cursor: not-allowed;
    box-shadow: none;
}

.tab-button.disabled:hover {
    background: #cccccc;
    color: #666666;
}

/* Content sections */
.week-content, .day-content {
    display: none; /* Hidden by default */
    padding: 10px;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    text-align: left; /* Ensure text alignment is natural */
}

.active-content {
    display: block; /* Shown when active */
}

/* Styling for daily content sections within weeks */
.day-section {
    margin-top: 20px; /* Space between the daily tabs and content */
    padding: 20px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.day-section h2 {
    color: #00408f;
    text-align: center;
    margin-bottom: 20px;
    font-size: 1.8em;
    border-bottom: 2px solid #007BFF;
    padding-bottom: 10px;
}

.content-block {
    margin-bottom: 20px;
    /* Ensure no extra padding/margin on the content block itself
        that might throw off the alignment for its children */
    padding-left: 0;
    padding-right: 0;
}

/* Headings within content block - ensure they have no left margin/padding */
.content-block h3,
.content-block h4 {
    color: #1E88E5;
    /* Adjust margin-bottom to control space before the list */
    margin-bottom: 3px; /* Reduced for tighter spacing */
    margin-left: 0; /* Crucial: Align heading text to the very left of .content-block */
    padding-left: 0; /* Crucial: Align heading text to the very left of .content-block */
    text-align: left; /* Ensure text is left-aligned */
}

.content-block p {
    margin-bottom: 10px;
    line-height: 1.6; /* Improved readability for text */
}

/* ---------------------------------------------------- */
/* Unordered Lists (UL) - Circle Bullets */
/* ---------------------------------------------------- */
.content-block ul {
    list-style: none; /* Remove default bullets */
    margin-left: 0; /* Align the list's left edge with the heading */
    padding-left: 0; /* Remove browser's default padding */
    margin-top: 0; /* Pull list closer to the heading */
    margin-bottom: 10px;
    text-align: left;
}

.content-block ul li {
    margin-bottom: 5px;
    position: relative; /* Needed for ::before positioning */
    line-height: 1.6; /* Ensure consistent line spacing */

    /* Padding to create space for the circle bullet and gap */
    padding-left: 18px; /* Space for the circle bullet + small gap */
}

/* Custom Circle Bullet using ::before pseudo-element for UL */
.content-block ul li::before {
    content: "•"; /* Unicode character for a solid circle */
    color: #00408f; /* Matching blue */
    font-weight: bold; /* Make it more prominent */
    font-size: 1em; /* Ensure the bullet size matches the text */

    position: absolute; /* Position the bullet absolutely relative to the list item */
    left: 0; /* Align it to the very left edge of the LI's content area */
    top: 0; /* Align with the top of the text */
    margin-right: 8px; /* Space between the bullet and the start of the list item text */
}

/* ---------------------------------------------------- */
/* Ordered Lists (OL) - Numbered Bullets */
/* ---------------------------------------------------- */
.content-block ol {
    list-style: none; /* Crucial: Remove default numbers to use custom counters */
    margin-left: 0; /* Align the list's left edge with the heading */
    padding-left: 0; /* Remove browser's default padding */
    margin-top: 0; /* Pull list closer to the heading */
    margin-bottom: 10px;
    text-align: left;

    /* Initialize the counter for ordered lists */
    counter-reset: custom-numbered-list;
}

.content-block ol li {
    margin-bottom: 5px;
    line-height: 1.6; /* Ensure consistent line spacing */
    position: relative; /* Needed for positioning the ::before pseudo-element */

    /* Padding to create space for the number (e.g., "10.") and gap.
        Adjust this based on the max number of items you expect (e.g., if you go to 100, you need more space). */
    padding-left: 30px; /* Space for the number and text content */
}

/* Custom Numbered Bullet using ::before pseudo-element for OL */
.content-block ol li::before {
    /* Increment the counter for each list item */
    counter-increment: custom-numbered-list;
    /* Display the counter value followed by a period */
    content: counter(custom-numbered-list) ".";

    color: #00408f; /* Matching blue */
    font-weight: bold;
    font-size: 1em; /* Ensure the number size matches the text */

    position: absolute; /* Position the number absolutely relative to the list item */
    left: 0; /* Align it to the very left edge of the LI's content area */
    top: 0; /* Align with the top of the text */
    text-align: right; /* Right-align the number within its allotted width */
    width: 25px; /* Fixed width for numbers (e.g., "1." and "10." align right within this width) */
    margin-right: 5px; /* Space between the number and the start of the list item text */
}

code {
    display: block;
    background-color: #e6f7ff;
    color: #333;
    padding: 15px;
    border-radius: 6px;
    overflow-x: auto;
    font-family: 'Consolas', 'Monaco', 'Andale Mono', 'Ubuntu Mono', monospace;
    font-size: 0.95em;
    white-space: pre-wrap; /* Ensures line breaks are respected */
    word-wrap: break-word; /* Breaks long words if necessary */
}

pre code {
    padding: 0;
    background: none;
    color: inherit;
    font-size: 1em;
    white-space: pre;
}

.example-label {
    font-weight: bold;
    color: #00408f;
    margin-top: 15px;
    display: block;
}

/* Add this to your existing CSS file or style block */

.week-content.content-disabled-overlay,
.day-content.content-disabled-overlay {
    position: relative;
    filter: blur(10px); /* Increased blur amount from 5px to 10px */
    pointer-events: none; /* Disables all mouse events on the blurred content */
    user-select: none; /* Prevents text selection */
    opacity: 0.6; /* Optional: Make it slightly faded */
}

/* Optional: Add an actual overlay on top if you want a more distinct disabled look */
.week-content.content-disabled-overlay::before,
.day-content.content-disabled-overlay::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.3); /* Semi-transparent white overlay */
    z-index: 1; /* Make sure it's above the blurred content */
}
/* --- Mobile Responsiveness for Content and Buttons --- */

/* Small devices (phones, 600px and down) */
@media only screen and (max-width: 600px) {
    .content-container-wrapper {
        width: 95%; /* Slightly more width on small screens */
        padding: 10px;
        margin: 10px auto 70px auto;
    }

    .main-tab-nav {
        flex-direction: row; /* Ensure horizontal flow */
        justify-content: center;
        flex-wrap: wrap; /* ALLOW WRAPPING for buttons on smaller screens */
        padding: 5px;
        /* Removed overflow-x: auto; as wrapping is now allowed */
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    /* --- Specific Adjustments for Week Buttons (assuming these are .tab-button within .main-tab-nav) --- */
    .main-tab-nav .tab-button { /* Targeting .tab-button specifically within .main-tab-nav */
        /*
         * To allow buttons to wrap while still trying to maintain a proportional width,
         * we use flex-basis. If there are 5 buttons, 18% allows for margins and wrapping.
         */
        flex: 1 1 18%; /* Target ~18% width per button, allowing wrapping */
        min-width: 0; /* Allow them to shrink as much as needed */
        margin: 2px; /* Small margin for consistent spacing */
        font-size: 10px; /* Potentially smaller font for weeks to fit */
        padding: 6px 2px; /* Even tighter padding for weeks */

        /* Ensure text visibility */
        white-space: normal; /* Allow text to wrap naturally within the button */
        overflow: visible; /* Ensure all content is visible */
        text-overflow: clip; /* Prevent ellipsis, show all text */
        word-break: break-word; /* Allows long words to break and wrap to the next line */
    }

    .nested-tab-nav {
        flex-direction: row; /* Ensure horizontal flow */
        justify-content: center;
        flex-wrap: wrap; /* ALLOW WRAPPING for buttons on smaller screens */
        padding: 5px;
        /* Remove overflow-x: auto; as wrapping is now allowed, horizontal scrolling is less likely needed */
        /* If buttons still overflow due to min-width, consider adjusting min-width further or ensuring content fits */
    }

    /* General Tab Button Styling for Mobile */
    .tab-button {
        flex: 1 1 auto; /* Allows buttons to grow and shrink */
        /* Consider a small min-width here, e.g., 30% or 80px, depending on how many buttons per row are desired.
           Setting it to 0 might make them too small if there are many. Let's keep it at 0 for maximum flexibility. */
        min-width: 0; /* Allow them to shrink as much as needed */
        margin: 2px; /* Small margin for consistent spacing */
        font-size: 11px; /* Base font size for mobile */
        padding: 6px 4px; /* Reduced horizontal padding to save space */
        /* Ensure text visibility by using word-break and removing hiding properties */
        white-space: normal; /* Allow text to wrap naturally within the button */
        overflow: visible; /* Ensure all content is visible */
        text-overflow: clip; /* Prevent ellipsis, show all text */
        word-break: break-word; /* Allows long words to break and wrap to the next line */
    }
    /* Content and other elements responsiveness (no change needed here for this specific request) */
    .day-section {
        padding: 15px;
    }

    .day-section h2 {
        font-size: 1.4em;
    }

    .content-block h3,
    .content-block h4 {
        font-size: 1.1em;
        margin-bottom: 2px;
    }

    .content-block p,
    .content-block ul li,
    .content-block ol li {
        font-size: 0.9em;
    }

    .content-block ul li {
        padding-left: 15px;
    }
    .content-block ul li::before {
        margin-right: 4px;
        font-size: 0.9em;
    }

    .content-block ol li {
        padding-left: 25px;
    }
    .content-block ol li::before {
        width: 20px;
        margin-right: 3px;
        font-size: 0.9em;
    }

    code {
        font-size: 0.8em;
        padding: 8px;
    }
    /* ... other mobile styles ... */
    .content-access-button {
        padding: 6px 10px;
        font-size: 0.8em;
    }
    /* REDUCE SIZE OF NAVIGATION BUTTONS FOR MOBILE VIEW */
    .nav-button {
        padding: 6px 8px; /* Smaller padding */
        font-size: 0.75em; /* Smaller font size */
        margin: 2px; /* Reduce margin between buttons */
    }
    .button-container {
        padding: 10px; /* Adjust padding for the button container */
        text-align: center; /* Center buttons if they wrap */
    }

    /* --- Quiz Specific Mobile Styles --- */
    .quiz-container {
        padding: 10px; /* Reduce padding for the entire quiz container */
        margin-top: 15px; /* Adjust top margin */
    }

    .quiz-container h3 {
        font-size: 1.2em; /* Smaller font for quiz title */
        margin-bottom: 10px;
    }

    .question-block {
        margin-bottom: 15px; /* Space between questions */
    }

    .question-block p {
        font-size: 1em; /* Adjust question text size */
        margin-bottom: 8px;
    }

    .quiz-option {
        padding: 8px 10px; /* Smaller padding for options */
        font-size: 0.9em; /* Smaller font size for options */
        margin-bottom: 6px; /* Space between options */
        min-height: 35px; /* Ensure a decent tap target size */
    }

    .quiz-feedback {
        font-size: 0.9em; /* Smaller font for feedback */
        padding: 6px 10px; /* Smaller padding for feedback */
        margin-top: 8px; /* Adjust top margin for feedback */
    }
}
/* Medium devices (tablets, 601px to 900px) */
@media only screen and (min-width: 601px) and (max-width: 900px) {
    .content-container-wrapper {
        width: 90%;
        padding: 20px;
    }

    .tab-button {
        font-size: 13px;
        padding: 7px 10px;
        min-width: 90px; /* Slightly larger min-width for tablets */
    }

    .day-section {
        padding: 20px;
    }

    .day-section h2 {
        font-size: 1.6em;
    }

    .content-block h3 {
        font-size: 1.3em;
    }

    code {
        font-size: 0.9em;
        padding: 12px;
    }
}
/* Table Styling - General (applies to all screen sizes unless overridden) */
.content-block table {
    width: 100%; /* Default to 100% width */
    border-collapse: collapse;
    margin-top: 15px;
    margin-bottom: 20px;
    font-size: 0.95em;
    /* Remove table-layout: fixed; here. It can constrain the table too much on small screens.
        Let the table content dictate its width within the scrollable container. */
}

.content-block th,
.content-block td {
    border: 1px solid #ddd;
    padding: 12px;
    text-align: left;
    word-wrap: break-word; /* Prevents long words from breaking layout */
}

.content-block th {
    background-color: #00408f;
    color: white;
    font-weight: bold;
}

.content-block tr:nth-child(even) {
    background-color: #f2f2f2;
}

.content-block tr:hover {
    background-color: #e0e0e0;
}

/* --- Mobile Responsiveness for Content and Buttons --- */

/* Small devices (phones, 600px and down) */
@media only screen and (max-width: 600px) {
    .content-container-wrapper {
        width: 95%; /* Slightly more width on small screens */
        padding: 10px;
        margin: 10px auto 70px auto;
    }

    /* For both main and nested tab navigation */
    .main-tab-nav,
    .nested-tab-nav {
        flex-direction: row; /* Ensure horizontal flow */
        justify-content: center;
        flex-wrap: nowrap; /* PREVENT WRAPPING for buttons */
        padding: 5px;
        /* Add overflow-x here to enable horizontal scrolling for buttons if they exceed */
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    /* General Tab Button Styling for Mobile */
    .tab-button {
        flex: 1 1 auto; /* Allows buttons to grow and shrink */
        min-width: 0; /* Allow them to shrink as much as needed */
        margin: 2px; /* Small margin for consistent spacing */
        font-size: 11px; /* Base font size for mobile */
        padding: 6px 4px; /* Reduced horizontal padding to save space */
        white-space: nowrap; /* Prevent text wrapping inside buttons */
        overflow: hidden; /* Hide overflowing text if it gets too small */
        text-overflow: ellipsis; /* Add ellipsis for hidden text */
    }

    /* --- Specific Adjustments for Week Buttons --- */
    .main-tab-nav .tab-button {
        flex: 1 1 18%; /* Target ~18% width per button (20% - margins) */
        font-size: 10px; /* Potentially smaller font for weeks to fit 5 */
        padding: 6px 2px; /* Even tighter padding for weeks */
    }

    /* --- Specific Adjustments for Weekday Buttons --- */
    .nested-tab-nav .tab-button {
        flex: 1 1 18%; /* Target ~18% width per button (20% - margins) */
        font-size: 10px; /* Smallest font size for weekdays to fit 5 */
        padding: 6px 2px; /* Tighter padding for weekdays */
    }

    /* Content and other elements responsiveness */
    .day-section {
        padding: 15px;
    }

    .day-section h2 {
        font-size: 1.4em;
    }

    .content-block h3,
    .content-block h4 {
        font-size: 1.1em;
        margin-bottom: 2px;
    }

    .content-block p,
    .content-block ul li,
    .content-block ol li {
        font-size: 0.9em;
    }

    .content-block ul li {
        padding-left: 15px;
    }
    .content-block ul li::before {
        margin-right: 4px;
        font-size: 0.9em;
    }

    .content-block ol li {
        padding-left: 25px;
    }
    .content-block ol li::before {
        width: 20px;
        margin-right: 3px;
        font-size: 0.9em;
    }

    code {
        font-size: 0.8em;
        padding: 8px;
    }
 .table-responsive {
        overflow-x: auto; /* Enables horizontal scrolling */
        -webkit-overflow-scrolling: touch; /* For smooth scrolling on iOS */
    }

    .content-block table {
        width: 100%;
        min-width: 400px; /* Ensures the table itself has a minimum size */
        table-layout: auto;
    }
    /* Remove the problematic display changes for table elements on mobile */
    .content-block table,
    .content-block thead,
    .content-block tbody,
    .content-block th,
    .content-block td,
    .content-block tr {
        display: table-cell; /* Revert to default table display properties, adjusted below */
    }

    .content-block tr {
        display: table-row; /* Ensure rows display as table rows */
    }

    .content-block thead {
        display: table-header-group; /* Ensure thead displays correctly */
    }

    .content-block tbody {
        display: table-row-group; /* Ensure tbody displays correctly */
    }

    .content-block th,
    .content-block td {
        display: table-cell; /* Ensure th and td display as table cells */
    }

    .content-block thead tr {
        position: static; /* Revert position */
        top: auto;
        left: auto;
    }

    /* Ensure padding and text alignment are standard for a scrollable table */
    .content-block td {
        border: 1px solid #ddd; /* Re-add borders */
        padding: 8px; /* Slightly reduced padding for mobile table cells */
        text-align: left; /* Keep text alignment left */
    }

    .content-block th {
        padding: 8px; /* Slightly reduced padding for mobile table headers */
    }

    .content-block td::before {
        content: none; /* Crucial: Remove the data-label pseudo-element */
    }
}
 .content-block-table {
                min-width: 300px; /* Maintain minimum width for scrollable table */
            }
            .content-block-table th, .content-block-table td {
                font-size: 0.8em;
                padding: 8px;
            }
            /* Adjustments for board members table on small screens */
            .board-members-table th,
            .board-members-table td {
                padding: 5px; /* Significantly reduced padding */
                font-size: 0.75em; /* Even smaller font size */
            }
/* Large devices (desktops, 901px and up - uses existing styles for max-width 900px and up) */
/* No specific media query needed here as base styles handle larger screens */
.quiz-container {
    margin-top: 30px;
    padding: 20px;
    background-color: #f9f9f9;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    text-align: left;
}

.quiz-container h3 {
    color: #00408f;
    text-align: center;
    margin-bottom: 20px;
    font-size: 1.5em;
    border-bottom: 2px solid #007BFF;
    padding-bottom: 10px;
}

.question-block {
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px dashed #cccccc;
}

.question-block:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.question-block p {
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
}

.options label { /* This specific style is no longer strictly needed but keeping for reference if old radio buttons exist */
    display: block;
    margin-bottom: 8px;
    cursor: pointer;
    font-size: 1em;
    color: #555;
}

/* NEW STYLES FOR TOUCHABLE OPTIONS */
.quiz-option {
    padding: 10px 15px;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s;
    background-color: #fff;
    color: #333;
}

.quiz-option:hover {
    background-color: #eef;
    border-color: #007BFF;
    color: #007BFF;
}

.quiz-option.selected {
    background-color: #007BFF; /* Blue background for selected */
    color: white;
    border-color: #00408f;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}


.quiz-feedback {
    margin-top: 15px;
    padding: 10px;
    border-radius: 5px;
    font-weight: bold;
    display: none; /* Hidden by default */
}

.quiz-feedback.correct {
    background-color: #d4edda;
    color: #155724;
    border-color: #c3e6cb;
}

.quiz-feedback.incorrect {
    background-color: #f8d7da;
    color: #721c24;
    border-color: #f5c6cb;
}
    </style>
</head>
<body>

    <div class="blue-container">
        <div class="left-aligned">
            <a href="index.html">
                <img src="MCE_tab.png" alt="Logo" class="favicon-logo">
            </a>
            <div class="titles">
                <h1 class="college-name">Mangayarkarasi College of Engineering</h1>
                <h2 class="site-title">The Coders Club</h2>
            </div>
        </div>
    </div>
    <div class="button-container">
        <button class="b-nav-button" onclick="window.location.href='index.html';">Home</button>
        <button class="b-nav-button active-nav-button" onclick="window.location.href='weeklycontent.html';">Weekly Content</button>
        <button class="b-nav-button" onclick="window.location.href='quiz.html';">Brain Cache</button>
        <button class="b-nav-button" onclick="window.location.href='finalquiz.html';">Mindmash</button>
        <button class="b-nav-button" onclick="window.location.href='leaderboard.html';">Leaderboard</button>
        <button class="b-nav-button" onclick="window.location.href='feedback.html';">Feedback</button>
    </div>

    <div class="content-container-wrapper">
        <div class="main-tab-nav">
            <button class="tab-button" onclick="showWeek('week1', this)">Week 1</button>
            <button class="tab-button" onclick="showWeek('week2', this)">Week 2</button>
            <button class="tab-button" onclick="showWeek('week3', this)">Week 3</button>
            <button class="tab-button" onclick="showWeek('week4', this)">Week 4</button>
            <button class="tab-button" onclick="showWeek('week5', this)">Week 5</button>
            <button class="tab-button" onclick="showWeek('week6', this)">Week 6</button>
            <button class="tab-button" onclick="showWeek('week7', this)">Week 7</button>
            <button class="tab-button" onclick="showWeek('week8', this)">Week 8</button>
            <button class="tab-button" onclick="showWeek('week10', this)">Mindmash</button>
        </div>

        <div id="week1" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 1 - Introduction to DSA & Time Complexity
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week1', this, 'week1')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week1', this, 'week1')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week1', this, 'week1')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week1', this, 'week1')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week1', this, 'week1')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week1', this, 'week1')">Saturday</button>
    </div>

    <div id="monday-content-week1" class="day-content day-section">
<h2>Monday Maverick</h2>
<div class="content-block">
<h3> What are Data Structures and Algorithms (DSA)?</h3>
<p><strong>Data Structures (DS)</strong></p>
<p>Data structures are special ways of organizing and storing data in computers so that we can perform operations on them efficiently.</p>
<h3>Examples:</h3>
<ul>
<li>Arrays</li>
<li>Linked Lists</li>
<li>Stacks & Queues</li>
<li>Trees (like BST, AVL)</li>
<li>Graphs</li>
<li>Hash Tables</li>
</ul>
</div>
</div>

    <div id="tuesday-content-week1" class="day-content day-section">
<h2>Techie Tuesday</h2>
<div class="content-block">
<h3>DSA: Power Up Your Code!</h3>
<p>Think of DSA (Data Structures & Algorithms) as your coding toolbox.</p>
<p>Data Structures = How you arrange and store data</p>
<p>Algorithms = How you think and solve problems step-by-step</p>
<p>But here’s the twist:</p>
<ol>
  <li>Anyone can write code.</li>
  <li>DSA makes it smart, fast, and clean.</li></ol>
<p>Learn DSA to:</p>
      <ol><li>Crack coding rounds</li>
      <li>Build efficient apps</li>
      <li>Win hackathons</li>
      <li>Boost logical thinking</li>
    </ol>
  </li>
<p>It’s not just theory — DSA is real-world coding power!</p>
<p>“Code is the language, DSA is the logic behind it.”</p>
</div>
</div>


<div id="wednesday-content-week1" class="day-content day-section">
    <h2>Syntax Snapshot Wednesday</h2>
    <div class="content-block">
        <h3>Algorithm Analysis: Time & Space Complexity</h3>
        <p>Understanding how efficient an algorithm is can make or break your code — especially in  competitive coding and real-world apps.</p>
        <p><strong>Time Complexity</strong><br>Measures how the execution time of an algorithm grows with input size n.</p>
        <h4>Common Notations:</h4>
        <ul>
            <li><strong>O(1)</strong> → Constant time (super fast)</li>
            <li><strong>O(log n)</strong> → Logarithmic (e.g., Binary Search)</li>
            <li><strong>O(n)</strong> → Linear (e.g., Linear Search)</li>
            <li><strong>O(n log n)</strong> → Log-linear (e.g., Merge Sort)</li>
            <li><strong>O(n²)</strong> → Quadratic (e.g., Bubble Sort)</li>
        </ul>
        <p><strong>Think:</strong> How many steps does my code take as input grows?</p>
        <p><strong>Pro Tip:</strong> Always aim for the lowest complexity possible for large datasets.</p>
        <p><strong>Space Complexity:</strong> Tracks how much extra memory an algorithm uses as input grows.</p>
        <h4>Examples:</h4>
        <ul>
            <li>A function with a few variables = O(1)</li>
            <li>Recursion with depth n = O(n)</li>
        </ul>
        <p><strong>Always balance:</strong>
            <ul><li>Time vs Space</li><li>Readability vs Optimization</li></ul>
    </div>
</div>

    <div id="thursday-content-week1" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <h3>Big O Notation (Big O) in DSA – Simple Explanation with Examples</h3>
        <p>Big O Notation is a way to describe the performance or complexity of an algorithm, especially in terms of time or space (memory) as the input size n grows.</p>
        <h3> Why is it important?</h3>
        <ul>
            <li>It helps you compare algorithms.</li>
            <li>It predicts how the algorithm will scale.</li>
            <li>It shows the worst-case scenario.</li>
        </ul>
        <h3>Common Big O Notations:</h3>
        
        <div class="table-responsive">
            <table>
                <thead>
                    <tr>
                        <th>Notation</th>
                        <th>Name</th>
                        <th>Example Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>O(1)</td>
                        <td>Constant Time</td>
                        <td>Accessing an array element: arr[3]</td>
                    </tr>
                    <tr>
                        <td>O(log n)</td>
                        <td>Logarithmic Time</td>
                        <td>Binary Search</td>
                    </tr>
                    <tr>
                        <td>O(n)</td>
                        <td>Linear Time</td>
                        <td>Loop through an array once</td>
                    </tr>
                    <tr>
                        <td>O(n log n)</td>
                        <td>Linearithmic Time</td>
                        <td>Merge Sort, Quick Sort (avg. case)</td>
                    </tr>
                    <tr>
                        <td>O(n²)</td>
                        <td>Quadratic Time</td>
                        <td>Nested loops (like Bubble Sort)</td>
                    </tr>
                    <tr>
                        <td>O(2ⁿ)</td>
                        <td>Exponential Time</td>
                        <td>Solving Towers of Hanoi, Recursion-heavy</td>
                    </tr>
                    <tr>
                        <td>O(n!)</td>
                        <td>Factorial Time</td>
                        <td>Brute-force permutations (like Travelling Salesman)</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <h3>Simple Examples:</h3>
        <h4> Example 1: O(1) – Constant Time</h4>
        <div class="code-block">
            <pre><code>def get_first_element(arr):
    return arr[0]</code></pre>
        </div>
        <p>No matter how big arr is, it just returns the first element.</p>
        <h4>Example 2: O(n) – Linear Time</h4>
        <div class="code-block">
            <pre><code>def print_all_elements(arr):
    for item in arr:
        print(item)</code></pre>
        </div>
        <p>As the array size grows, the number of operations grows linearly.</p>
        <h4>Example 3: O(n²) – Quadratic Time</h4>
        <div class="code-block">
            <pre><code>def print_pairs(arr):
for i in arr:
    for j in arr:
      print(i, j)</code></pre>
        </div>
        <p>Two nested loops: if arr has 5 items, total prints = 5×5 = 25</p>
        <h4>Example 4: O(log n) – Logarithmic Time (Binary Search)</h4>
        <div class="code-block">
            <pre><code>def binary_search(arr, target):
low, high = 0, len(arr) - 1
while low <= high:
    mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1</code></pre>
        </div>
        <p>With each step, the search space is halved.</p>
    </div>
</div>
    <div id="friday-content-week1" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Analyzing Time Complexity of Basic C Programs:</h3>
        <p>Time complexity is a measure of how long an algorithm takes to complete, usually expressed as a function of the input size. Let's analyze the time complexity of a basic C program.</p>
        <h3>Example Program: Finding the Maximum Element in an Array</h3>
        <div class="code-block">
            <pre><code>#include &lt;stdio.h&gt;
int findMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

int main() {
    int arr[] = {4, 2, 9, 6, 5, 1};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Maximum element: %d\n",
    findMax(arr, n));
    return 0;
}</code></pre>
        </div>
        <h3>Time Complexity Analysis:</h3>
        <p>The <strong>findMax</strong> function iterates through the array once, comparing each element with the current maximum. The number of operations (comparisons and assignments) grows linearly with the size of the input array <strong>n</strong>.</p>
        <ul>
            <li><strong>Best-case scenario:</strong> The maximum element is at the first position, but the algorithm still iterates through the entire array, resulting in a time complexity of O(n)</li>
            <li><strong>Worst-case scenario:</strong> The maximum element is at the last position, and the algorithm still iterates through the entire array, resulting in a time complexity of O(n)</li>
            <li><strong>Average-case scenario:</strong> The maximum element can be anywhere in the array, but the algorithm still iterates through the entire array, resulting in a time complexity of O(n)</li>
        </ul>
        <p>Therefore, the time complexity of the <strong>findMax</strong> function is O(n), where n is the size of the input array.</p>
        <h3>Explanation:</h3>
        <ul>
            <li>The time complexity is O(n) because the algorithm performs a constant amount of work for each element in the input array.</li>
            <li>The loop iterates <strong>n-1</strong> times, and each iteration performs a constant number of operations (one comparison and potentially one assignment).</li>
            <li>The time complexity is linear because the running time grows directly proportional to the size of the input array.</li>
        </ul>
        <h3>Examples:</h3>
        <h4>Example 1: Small Array</h4>
        <p>Input: <pre><code>arr[] = {3, 1, 4, 2}</code></pre><br>
        Output: <code>Maximum element: 4</code></p>
        <ul>
            <li>Number of iterations: 3 (n-1 = 4-1 = 3)</li>
            <li>Time complexity: O(n) = O(4)</li>
        </ul>
        <h4>Example 2: Large Array</h4>
        <p>Input: <pre><code>arr[] = {10, 20, 30, 40, 50, 60, 70, 80,
        90, 100}</code></pre><br>
        Output: <code>Maximum element: 100</code></p>
        <ul>
            <li>Number of iterations: 9 (n-1 = 10-1 = 9)</li>
            <li>Time complexity: O(n) = O(10)</li>
        </ul>
        <h4>Example 3: Array with Maximum Element at First Position</h4>
        <p>Input: <pre><code>arr[] = {100, 20, 30, 40, 50, 60, 70, 80,
        90, 10}</code></pre><br>
        Output: <code>Maximum element: 100</code></p>
        <ul>
            <li>Number of iterations: 9 (n-1 = 10-1 = 9)</li>
            <li>Time complexity: O(n) = O(10)</li>
        </ul>
        <h4>Example 4: Array with Maximum Element at Last Position</h4>
        <p>Input: <pre><code>arr[] = {10, 20, 30, 40, 50, 60, 70, 80,
        90, 100}</code></pre><br>
        Output: <code>Maximum element: 100</code></p>
        <ul>
            <li>Number of iterations: 9 (n-1 = 10-1 = 9)</li>
            <li>Time complexity: O(n) = O(10)</li>
        </ul>
    </div>
</div>
<div id="saturday-content-week1" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. The "Undo" feature in a text editor is usually implemented using:</h3>
        <ol>
            <li>Queue</li>
            <li><strong>Stack</strong></li>
            <li>Array</li>
            <li>Hash Table</li>
        </ol>
        <h3>2. Why is learning DSA important for developers?</h3>
        <ol>
            <li>To make code look colorful</li>
            <li><strong>To build efficient and optimized solutions</strong></li>
            <li>To avoid writing comments in code</li>
            <li>To learn more programming languages</li>
        </ol>
        <h3>3. Which of the following statements about time and space complexity is always true?</h3>
        <ol>
            <li>If an algorithm has better time complexity, it will always have better space complexity too.</li>
            <li>An algorithm with O(1) space complexity never uses any memory beyond input.</li>
            <li><strong>It is possible for two different algorithms solving the same problem to have the same time complexity but different space complexities.</strong></li>
            <li>Space complexity only depends on the size of the input, not on the operations performed.</li>
        </ol>
        <h3>4. A programmer needs to choose between two algorithms. Algorithm A has a time complexity of O(n log n), and Algorithm B has a time complexity of O(n^2). As the input size (n) increases, which of the following statements is true regarding their efficiency?</h3>
        <ol>
            <li>Algorithm B is more efficient because a quadratic function grows slower than a linearithmic function.</li>
            <li>Both algorithms have similar efficiency, so the choice between them does not matter.</li>
            <li><strong>Algorithm A is more efficient because its number of operations grows much slower than Algorithm B's as n increases.</strong></li>
            <li>Algorithm B is more efficient because a larger exponent indicates a faster algorithm.</li>
        </ol>
        <h3>5. In the findMax function, if the size of the input array is 10, how many iterations will the loop perform?</h3>
        <pre><code>#include &lt;stdio.h&gt;

int findMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i &lt; n; i++) {
        if (arr[i] &gt; max) {
            max = arr[i];
        }
    }
    return max;
}

int main() {
    int arr[] = {4, 2, 9, 6, 5, 1};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Maximum element: %d\n",
    findMax(arr, n));
    return 0;
}
</code></pre>
        <ol>
            <li>8</li>
            <li><strong>9</strong></li>
            <li>10</li>
            <li>11</li>
        </ol>
    </div>
</div>
</div>


<div id="week2" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 2 - Arrays and Searching Algorithms
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week2', this, 'week2')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week2', this, 'week2')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week2', this, 'week2')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week2', this, 'week2')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week2', this, 'week2')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week2', this, 'week2')">Saturday</button>
    </div>

    <div id="monday-content-week2" class="day-content day-section">
    <h2>Monday Maverick</h2>
    <div class="content-block">
        <h3>Introduction to Arrays and Memory Representation in C:</h3>
        <h4>Concepts</h4>
        <p>An array in C is a collection of elements of the same data type, stored in contiguous memory locations. It allows storing multiple values under a single variable name, accessed using an index (starting from 0).</p>
        <h4>Syntax:</h4>
        <p><pre><code>datatype arrayName[size];</code></pre></p>
        <h4>Memory Representation:</h4>
        <ul><li>Elements are stored in continuous blocks of memory.</li>
        <li>Each element’s address is calculated as:
        <p><strong>Base_Address + (Index × Size_of_DataType)</strong></p></li></ul>
    </div>
</div>

<div id="tuesday-content-week2" class="day-content day-section">
    <h2>Techie Tuesday</h2>
    <div class="content-block">
        <h3>C++ Array Operations Explained</h3>
        <p>This C++ code demonstrates three fundamental operations on a data structure known as an <strong>array</strong>: <strong>insertion</strong>, <strong>traversal</strong>, and <strong>updation</strong>.</p>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4};
    int n = 4;

    // Insertion
    arr[n] = 5; // Insert at end
    n++;

    // Traversal
    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";

    // Updation
    arr[2] = 99; // Update element at index 2
}</code></pre>

        <h4>Code Breakdown</h4>
        <ul>
            <li><strong>int arr[5] = {1, 2, 3, 4};</strong><br>
                This line declares an integer array named <strong>arr</strong> with a maximum size of 5. It's initialized with four elements: 1, 2, 3, and 4. The fifth slot is currently empty.</li>
            <li><strong>int n = 4;</strong><br>
                This variable <strong>n</strong> keeps track of the current number of elements in the array. Since we initialized the array with four elements, <strong>n</strong> is set to 4.</li>
        </ul>

        <h4>Insertion</h4>
        <p>This section adds a new element to the end of the array.</p>
        <ul>
            <li><strong>arr[n] = 5;</strong><br>
                The variable <strong>n</strong> currently holds the value 4, which is the index of the next available slot in the array (arr[4]). The code places the value <strong>5</strong> into this slot.</li>
            <li><strong>n++;</strong><br>
                After the insertion, <strong>n</strong> is incremented to 5, reflecting the new total number of elements.</li>
        </ul>

        <h4>Traversal</h4>
        <p><strong>Traversal</strong> means visiting every element in the array. This <strong>for</strong> loop is used to iterate through the array from the first element (index 0) up to the last element (index <strong>n-1</strong>).</p>
        <ul>
            <li><strong>for(int i = 0; i < n; i++)</strong><br>
                The loop starts at index 0, continues as long as the index <strong>i</strong> is less than the current size of the array (<strong>n</strong>), and increments <strong>i</strong> after each iteration.</li>
            <li><strong>cout << arr[i] << " ";</strong><br>
                Inside the loop, this line prints each element to the console, followed by a space. The output at this point would be: <strong>1 2 3 4 5</strong>.</li>
        </ul>

        <h4>Updation</h4>
        <p><strong>Updation</strong> means changing the value of an existing element. Here, the value at a specific index is replaced.</p>
        <ul>
            <li><strong>arr[2] = 99;</strong><br>
                This line accesses the element at index 2 (the third element in the array) and changes its value from <strong>3</strong> to <strong>99</strong>. The array now effectively contains <strong>{1, 2, 99, 4, 5}</strong>.</li>
        </ul>
    </div>
</div>

<div id="wednesday-content-week2" class="day-content day-section">
    <h2>Syntax Snapshots Wednesday</h2>
    <div class="content-block">
        <h3>Linear Search Algorithm</h3>

        <p><strong>Definition:</strong> Linear Search checks each element in the list one-by-one until the target is found or the end is reached.</p>

        <h4>Code (C Example):</h4>
        <pre><code>#include &lt;stdio.h&gt;

int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Found -> return index
        }
    }
    return -1; // Not found
}

int main() {
    int arr[] = {5, 8, 1, 4, 9};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 4;

    int result = linearSearch(arr, n, target);

    if (result != -1)
        printf("Element found at index %d\n", result);
    else
        printf("Element not found\n");

    return 0;
}</code></pre>

        <h4>Output:</h4>
        <code>Element found at index 3</code>

        <h4>Time Complexity:</h4>
        <ul>
            <li><strong>Best Case:</strong> O(1) &rarr; Found at the first position</li>
            <li><strong>Worst Case:</strong> O(n) &rarr; Found at the end or not present</li>
            <li><strong>Average Case:</strong> O(n)</li>
        </ul>

        <h4>Space Complexity:</h4>
        <p>O(1) &rarr; Uses constant extra space</p>

        <h4>Pros:</h4>
        <ul>
            <li>Very simple</li>
            <li>Works for unsorted data</li>
        </ul>

        <h4>Cons:</h4>
        <ul>
            <li>Inefficient for large datasets</li>
        </ul>
    </div>
</div>
   <div id="thursday-content-week2" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <h3>Binary Search &ndash; Key Points</h3>
        <h4>Definition</h4>
        <p>An efficient searching algorithm for <strong>sorted</strong> arrays/lists. It works by repeatedly dividing the search space in half until the target is found or the search space is empty.</p>
        <h4>Conditions</h4>
        <ul>
            <li>The array must be <strong>sorted</strong> (in ascending or descending order).</li>
            <li>Random access to elements must be possible (making it ideal for arrays, but not for linked lists).</li>
        </ul>
        <h4>Algorithm Steps</h4>
        <ol>
            <li>Set low = 0 and high = n - 1.</li>
            <li>Find the middle index: mid = (low + high) / 2.</li>
            <li>If arr[mid] == the target key, the element is found.</li>
            <li>If arr[mid] > the target key, search the left side by setting high = mid - 1.</li>
            <li>Otherwise (if arr[mid] < the target key), search the right side by setting low = mid + 1.</li>
            <li>Repeat the process until low is greater than high.</li>
        </ol>
        <h4>Time Complexity</h4>
        <ul>
            <li><strong>Best Case:</strong> O(1) &rarr; when the element is at the initial middle position.</li>
            <li><strong>Average/Worst Case:</strong> O(log₂n) &rarr; because the algorithm halves the search space with each step.</li>
            <li><strong>Space Complexity:</strong> O(1) for the iterative approach and O(log n) for the recursive approach (due to function call stack).</li>
        </ul>
        <h4>Advantages</h4>
        <ul>
            <li>Significantly faster than linear search for large, sorted datasets.</li>
            <li>Reduces the number of comparisons drastically.</li>
        </ul>
        <h4>Disadvantages</h4>
        <ul>
            <li>Works only on sorted collections.</li>
            <li>Insertion or deletion is costly in arrays, as the array must be sorted again.</li>
        </ul>
        <h4>Example (Ascending Order Search)</h4>
        <p><strong>Array:</strong> [2, 5, 8, 12, 16, 23, 38, 45, 50]<br><strong>Key:</strong> 23</p>
        <ul>
            <li>low = 0, high = 8, mid = 4 &rarr; arr[4] = 16 < 23 &rarr; search right side</li>
            <li>low = 5, high = 8, mid = 6 &rarr; arr[6] = 38 > 23 &rarr; search left side</li>
            <li>low = 5, high = 5, mid = 5 &rarr; arr[5] = 23 &rarr; found!</li>
        </ul>
    </div>
</div>

<div id="friday-content-week2" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Practice Problem: Array Manipulation and Searching</h3>
        <p>Given an array of integers, perform the following operations:</p>
        <ul>
            <li>Find the maximum element in the array.</li>
            <li>Find the minimum element in the array.</li>
            <li>Search for a specific element in the array.</li>
            <li>Insert a new element at a specific position in the array.</li>
            <li>Delete an element from the array.</li>
        </ul>
        <h4>Example</h4>
        <p>Suppose we have the following array: <code>[3, 1, 4, 2, 5]</code></p>
        <h4>Find the Maximum Element</h4>
        <ul>
            <li>Maximum element: 5</li>
            <li>Explanation: We iterate through the array and keep track of the maximum element found so far.</li>
        </ul>
        <h4>Find the Minimum Element</h4>
        <ul>
            <li>Minimum element: 1</li>
            <li>Explanation: We iterate through the array and keep track of the minimum element found so far.</li>
        </ul>
        <h4>Search for a Specific Element</h4>
        <ul>
            <li>Search for element: 4</li>
            <li>Result: Element found at index 2</li>
            <li>Explanation: We iterate through the array and check if the element is present.</li>
        </ul>
        <h4>Insert a New Element at a Specific Position</h4>
        <ul>
            <li>Insert element: 6 at position 2</li>
            <li>Result: <code>[3, 1, 6, 4, 2, 5]</code></li>
            <li>Explanation: We shift the elements to the right of the insertion position and insert the new element.</li>
        </ul>
        <h4>Delete an Element from the Array</h4>
        <ul>
            <li>Delete element: 4</li>
            <li>Result: <code>[3, 1, 2, 5]</code></li>
            <li>Explanation: We shift the elements to the left of the deletion position and remove the element.</li>
        </ul>
        <h4>Code Implementation (C)</h4>
        <pre><code>#include &lt;stdio.h&gt;

// Function prototypes (assumed to be defined elsewhere for a complete program)
// int findMax(int arr[], int n);
// int findMin(int arr[], int n);
// int searchElement(int arr[], int n, int target);
// void insertElement(int arr[], int* n, int pos, int element);
// void deleteElement(int arr[], int* n, int pos);

int main() {
    int arr[] = {3, 1, 4, 2, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    // Find maximum element
    printf("Maximum element: %d\n", findMax(arr, n));

    // Find minimum element
    printf("Minimum element: %d\n", findMin(arr, n));

    // Search for an element
    int target = 4;
    int index = searchElement(arr, n, target);
    if (index != -1) {
        printf("Element %d found at index %d\n", target, index);
    } else {
        printf("Element %d not found\n", target);
    }

    // Insert an element
    int pos = 2;
    int element = 6;
    insertElement(arr, &n, pos, element);
    printf("Array after insertion: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Delete an element
    pos = 2;
    deleteElement(arr, &n, pos);
    printf("Array after deletion: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}</code></pre>

        <h4>Output:</h4>
<code>Maximum element: 5
Minimum element: 1
Element 4 found at index 2
Array after insertion: 3 1 6 4 2 5 
Array after deletion: 3 1 2 5 </code>
</div></div>
    <div id="saturday-content-week2" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. char arr[4] = {'A', 'B', 'C', 'D'};<br>If Base_Address = 2000 and sizeof(char) = 1 byte, what will be the address of arr[2]?</h3>
        <ol>
            <li>2001</li>
            <li><strong>2002</strong></li>
            <li>2003</li>
            <li>2004</li>
        </ol>
        <h3>2. You are given an array: arr = {5, 15, 25, 35}<br>Perform the following operations:<br>
            <ul><li><strong>Insertion:</strong> Add 45 at the end.</li>
                <li><strong>Updation:</strong> Change the value at index 2 to 99.</li>
                <li><strong>Traversal:</strong> Print all the elements after the above changes.</li></ul></h3>
        <p><strong>Answer:</strong> 
            <ul>
                <li><strong>Insertion:</strong> {5, 15, 25, 35, 45}</li>
                <li><strong>Updation:</strong> {5, 15, 99, 35, 45}</li>
                <li><strong>Traversal:</strong> {5, 15, 99, 35, 45}</li>
            </ul></p>
            <p>or</p>
            <p><strong>Code:</strong></p>
            <pre><code>#include &lt;stdio.h&gt;

int main() {
    int arr[10] = {5, 15, 25, 35};
    int n = 4;   // current size of array

    // Insertion: Add 45 at the end
    arr[n] = 45;
    n++;

    // Updation: Change value at index 2 to 99
    arr[2] = 99;

    // Traversal: Print all elements
    printf("Array after changes: ");
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}</code></pre>
        <h3>3. Given the provided C code for a linear search function, what is the worst-case time complexity, and under which condition does it occur?</h3>
        <pre><code>#include &lt;stdio.h&gt;
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Found → return index
        }
    }
    return -1; // Not found
}

int main() {
    int arr[] = {5, 8, 1, 4, 9};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 4;

    int result = linearSearch(arr, n, target);

    if (result != -1)
        printf("Element found at index %d\n", result);
    else
        printf("Element not found\n");

    return 0;
}
</code></pre>
        <ol>
            <li>O(1), when the target element is found at the first index of the array.</li>
            <li><strong>O(n), when the target element is the last one in the array or is not present in the array at all.</strong></li>
            <li>O(n), when the array is unsorted, forcing a full traversal of the list.</li>
            <li>O(log n), because the search repeatedly divides the problem in half to find the target.</li>
        </ol>
        <h3>4. According to the provided key points, which of the following is a key disadvantage of the Binary Search algorithm?</h3>
        <ol>
            <li>It is less efficient than a linear search for large datasets.</li>
            <li>It can only be used on unsorted arrays.</li>
            <li>Its best-case time complexity is $O(\log_2n)$.</li>
            <li><strong>It works only on sorted collections.</strong></li>
        </ol>
        <h3>5. What will be the output of the following code snippet?</h3>
        <pre><code>int arr[] = {3, 1, 4, 2, 5};
int n = sizeof(arr) / sizeof(arr[0]);
int max = arr[0];
for (int i = 1; i < n; i++) {
    if (arr[i] > max) {
        max = arr[i];
    }
}
printf("%d", max);
</code></pre>
        <ol>
            <li>1</li>
            <li>3</li>
            <li>4</li>
            <li><strong>5</strong></li>
        </ol>
    </div>
</div>
</div>

        <div id="week3" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 3 - Sorting Techniques 
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week3', this, 'week3')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week3', this, 'week3')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week3', this, 'week3')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week3', this, 'week3')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week3', this, 'week3')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week3', this, 'week3')">Saturday</button>
    </div>

<div id="monday-content-week3" class="day-content day-section">
    <h2>Monday Mavericky</h2>
    <div class="content-block">
        <h3>Sorting Techniques</h3>

        <h4>Concept:</h4>
        <p>Sorting is a process of arranging data in a particular order—most commonly ascending (smallest to largest) or descending (largest to smallest).</p>
        <p>It is a fundamental concept in computer science because many tasks become easier and more efficient once the data is sorted (like searching, analyzing, or displaying results).</p>

        <h4>Types of Sorting:</h4>
        <ul>
            <li>Ascending / Descending order</li>
            <li>Alphabetical / Lexicographical order</li>
            <li>Based on key values (e.g., sorting students by marks, employees by salary)</li>
        </ul>

        <h4>Real World Application:</h4>
        <ul>
            <li>E-commerce → Sort products by price or rating</li>
            <li>Search engines → Results sorted by relevance/date</li>
            <li>Databases → ORDER BY queries for organized output</li>
            <li>Contacts & Files → Sorted by name, size, or date</li>
            <li>Banking → Transactions sorted by amount/date</li>
            <li>Task management → Tasks sorted by deadline/priority</li>
        </ul>
    </div>
</div>
<div id="tuesday-content-week3" class="day-content day-section">
    <h2>Techie Tuesday</h2>
    <div class="content-block">
        <h3>Bubble Sort vs Selection Sort</h3>

        <h4>Bubble Sort</h4>
        <p>Repeatedly compares adjacent elements and swaps them if they are in the wrong order.</p>
        <p><strong>Time Complexity:</strong></p>
        <ul>
            <li>Best Case → O(n) (already sorted)</li>
            <li>Worst Case → O(n²)</li>
        </ul>
        <p><strong>Code (Python):</strong></p>
        <pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

print(bubble_sort([64, 25, 12, 22, 11]))</code></pre>
<h4>Output</h4>
<code>11, 12, 22, 25, 64</code>

        <h4>Selection Sort</h4>
        <p>Selects the minimum element and places it at the correct position in each pass.</p>
        <p><strong>Time Complexity:</strong></p>
        <ul>
            <li>Best Case → O(n²)</li>
            <li>Worst Case → O(n²)</li>
        </ul>
        <p><strong>Code (Python):</strong></p>
        <pre><code>def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

print(selection_sort([64, 25, 12, 22, 11]))</code></pre>
        <h4>Output</h4>
        <code>11, 12, 22, 25, 64</code>
        <h4>Comparison Table</h4>
        <div class="table-responsive">
                <table class="content-block-table">
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Best Case</th>
                    <th>Worst Case</th>
                    <th>Stable?</th>
                    <th>Space</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Bubble Sort</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>Yes</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Selection Sort</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>No</td>
                    <td>O(1)</td>
                </tr>
            </tbody>
        </table></div>
        <p><strong>Insight:</strong>
            <ol><li>Bubble Sort is slightly better if the list is almost sorted, but Selection Sort does fewer swaps.</li>
            <li>Both are not efficient for large datasets – we use Merge Sort, Quick Sort, Heap Sort instead.</li></ol>  
    </div>
</div>

<div id="wednesday-content-week3" class="day-content day-section">
    <h2>Syntax Snapshots Wednesday</h2>
    <div class="content-block">
        <h3>Insertion Sort Algorithm</h3>

        <h4>Definition:</h4>
        <p>Insertion Sort builds the final sorted array one element at a time, by picking an element and inserting it into its correct position among the already sorted part.</p>

        <pre><code>#include &lt;stdio.h&gt;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        // Shift elements greater than key to one position ahead
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}</code></pre>
<h4>Output:</h4>
<code>Sorted array: 5 6 11 12 13</code>

        <h4>Time Complexity:</h4>
        <ul>
            <li><strong>Best Case (already sorted):</strong> O(n)</li>
            <li><strong>Worst Case (reverse sorted):</strong> O(n²)</li>
            <li><strong>Average Case:</strong> O(n²)</li>
        </ul>

        <h4>Space Complexity:</h4>
        <ul>
            <li>O(1) → In-place sorting</li>
        </ul>

        <h4>Pros:</h4>
        <ul>
            <li>Simple and easy to implement</li>
            <li>Efficient for small datasets or nearly sorted arrays</li>
        </ul>

        <h4>Cons:</h4>
        <ul>
            <li>Slow for large datasets (O(n²))</li>
        </ul>

        <h4>Practice Task:</h4>
        <ol>
            <li>Write an Insertion Sort program to sort an array in descending order.</li>
            <li>Try to count and print the number of comparisons made during sorting.</li>
        </ol>
    </div>
</div>

<div id="thursday-content-week3" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <h3>Merge Sort in DSA</h3>

        <h4>Steps of Merge Sort:</h4>
        <ol>
            <li><strong>Divide</strong> → Split the array into two halves.</li>
            <li><strong>Conquer</strong> → Recursively sort each half.</li>
            <li><strong>Combine</strong> → Merge the two sorted halves into a single sorted array.</li>
        </ol>

        <h4>Example:</h4>
        <p>Array = [38, 27, 43, 3, 9, 82, 10]</p>
        <p>Step 1: <strong>Divide</strong> → [38, 27, 43] and [3, 9, 82, 10]</p>
        <p>Step 2: <strong>Further divide</strong> → [38] [27,43] and [3,9] [82,10]</p>
        <p>Step 3: <strong>Sort & merge</strong> → [27,38,43] and [3,9,10,82]</p>
        <p>Step 4: <strong>Final merge</strong> → [3,9,10,27,38,43,82]</p>


        <h4>Time Complexity:</h4>
        <p>Best Case: O(n log n)</p>
        <p>Average Case: O(n log n)</p>
        <p>Worst Case: O(n log n)</p>

        <h4>Space Complexity:</h4>
        <p>O(n) (extra space required for merging)</p>

        <h4>Key Points:</h4>
        <ul>
            <li><strong>Always O(n log n)</strong> → more efficient than Bubble Sort/Insertion Sort.</li>
            <li>Uses recursion.</li>
            <li>Stable sorting algorithm (preserves order of equal elements).</li>
        </ul>
    </div>
</div>

    <div id="friday-content-week3" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Quick Sort</h3>
        <p>Quick sort is a popular sorting algorithm that uses the divide-and-conquer technique to sort an array of elements. Here's a concise summary:</p>

        <h4>Key Points</h4>
        <ul>
            <li><strong>Divide-and-Conquer</strong>: Divide the array into smaller sub-arrays and solve each sub-array recursively.</li>
            <li><strong>Pivot Selection</strong>: Choose a pivot element from the array to partition the other elements.</li>
            <li><strong>Partitioning</strong>: Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.</li>
            <li><strong>Recursion</strong>: Recursively apply the quick sort algorithm to the sub-arrays.</li>
            <li><strong>Combining</strong>: Combine the sorted sub-arrays to get the final sorted array.</li>
        </ul>

        <h4>Example</h4>
        <p>Suppose we have the array <strong>[5, 2, 9, 1, 7, 3]</strong>. We choose the first element <strong>5</strong> as the pivot, partition the array into <strong>[2, 1, 3]</strong> and <strong>[9, 7]</strong>, and recursively sort the sub-arrays. The final sorted array is <strong>[1, 2, 3, 5, 7, 9]</strong></p>

        <h4>Time Complexity</h4>
        <ul>
            <li><strong>Average Case</strong>: O(n log n)</li>
            <li><strong>Worst Case</strong>: O(n^2) if the pivot is chosen poorly.</li>
        </ul>

        <h4>C Implementation</h4>
        <p>The provided C implementation demonstrates the quick sort algorithm using a recursive approach. The <strong>partition</strong> function rearranges the array, and the <strong>quick_sort</strong> function recursively applies the partitioning process to the sub-arrays.</p>

        <h4>Output</h4>
        <p>The output of the C implementation shows the original array <strong>[5, 2, 9, 1, 7, 3]</strong> and the sorted array <strong>[1, 2, 3, 5, 7, 9]</strong>.</p>
    </div>
</div>
    <div id="saturday-content-week3" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. A librarian is reorganizing the library's entire collection of books. The goal is to arrange all the books on the shelves alphabetically by the author's last name so that a specific book can be located quickly. According to the provided content, which type of sorting is the librarian applying?</h3>
        <ol>
            <li>Ascending/Descending order</li>
            <li>Based on key values</li>
            <li><strong>Alphabetical/Lexicographical order</strong></li>
            <li>Ascending order</li>
        </ol>

        <h3>2. Based on the provided C code and your knowledge of sorting algorithms, which of the following is more stable?</h3>
        <p><strong>Code:</strong></p>
        <pre><code>#include &lt;stdio.h&gt;

void bubbleSort(int arr[], int n) {
int i, j, temp;
for (i = 0; i < n-1; i++) {
for (j = 0; j < n-i-1; j++) {
if (arr[j] > arr[j+1]) {
temp = arr[j];
arr[j] = arr[j+1];
arr[j+1] = temp;
}
}
}
}

void selectionSort(int arr[], int n) {
int i, j, min_idx, temp;
for (i = 0; i < n-1; i++) {
min_idx = i;
for (j = i+1; j < n; j++) {
if (arr[j] < arr[min_idx]) {
min_idx = j;
}
}
temp = arr[min_idx];
arr[min_idx] = arr[i];
arr[i] = temp;
}
}</code></pre>
        <ol>
            <li><strong>A. bubbleSort is more stable.</strong></li>
            <li>B. selectionSort is more stable.</li>
            <li>C. Both are equally stable.</li>
            <li>D. Neither algorithm is stable.</li>
        </ol>

        <h3>3. Given the initial array `int arr[] = {12, 11, 13, 5, 6};`, what will be the state of the array after the first iteration of the for loop in the insertionSort function (when i = 1)?</h3>
        <ol>
            <li><strong>A. {11, 12, 13, 5, 6}</strong></li>
            <li>B. {12, 11, 13, 5, 6}</li>
            <li>C. {11, 13, 12, 5, 6}</li>
            <li>D. {5, 6, 11, 12, 13}</li>
        </ol>

        <h3>4. What would be the first two sub-arrays after the "Divide" step of Merge Sort is applied to the array [5, 2, 8, 4, 1, 9]?</h3>
        <ol>
            <li><strong>[5, 2, 8] and [4, 1, 9]</strong></li>
            <li>[5, 2, 8, 4] and [1, 9]</li>
            <li>[5, 2] and [8, 4, 1, 9]</li>
            <li>[5] and [2, 8, 4, 1, 9]</li>
        </ol>

        <h3>5. What are the five key steps of the Quick Sort algorithm?</h3>
        <p><strong>Answer:</strong></p>
        <ul>
            <li>Pivot Selection</li>
            <li>Partitioning</li>
            <li>Recursion</li>
            <li>Combining</li>
            <li>Divide and Conquer</li>
        </ul>
    </div>
</div>
</div>

        <div id="week4" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 4 - Linked Lists
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week4', this, 'week4')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week4', this, 'week4')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week4', this, 'week4')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week4', this, 'week4')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week4', this, 'week4')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week4', this, 'week4')">Saturday</button>
    </div>

    
<div id="monday-content-week4" class="day-content day-section">
    <h2>Monday Maverick</h2>
    <div class="content-block">
        <h3>Introduction to Linked List:</h3>
        <p>A linear data structure where nodes are connected using pointers.</p>
        <p>Each node = data + pointer.</p>
        <p>Unlike arrays, linked lists are dynamic and non-contiguous.</p>

        <h3>Types of Linked Lists:</h3>
        <ul>
            <li>Singly Linked List – one pointer (next).</li>
            <li>Doubly Linked List – two pointers (next & prev).</li>
            <li>Circular Linked List – last node connects to first.</li>
            <li>Circular Doubly Linked List – combination of both.</li>
        </ul>

        <h3>Operations:</h3>
        <p>Insertion, Deletion, Traversal, Searching, Updating.</p>

        <h3>Use Cases:</h3>
        <ul>
            <li>Dynamic memory management.</li>
            <li>Implementing stacks, queues, graphs, hash tables.</li>
        </ul>

        <h3>Real-world:</h3>
        <ul>
            <li>Browser history</li>
            <li>text editor undo/redo</li>
            <li>playlists</li>
            <li>OS memory management.</li>
        </ul>

        <h3>Pros & Cons:</h3>
        <ul>
            <li>Dynamic size, easy insertion/deletion.</li>
            <li>Extra memory for pointers, no direct indexing.</li>
        </ul>
    </div>
</div>

    <div id="tuesday-content-week4" class="day-content day-section">
    <h2>Techie Tuesday</h2>
    <div class="content-block">
        <h3>Segment Tree</h3>

        <h4>What is a Segment Tree?</h4>
        <p>A Segment Tree is a binary tree data structure used for answering range queries and performing range updates efficiently.</p>

        <h4>Why not just use arrays?</h4>
        <p>For operations like finding sum/min/max in a subarray, arrays take O(n) per query.</p>
        <p>With Segment Tree, it reduces to O(log n) per query/update.</p>

        <h4>How it works?</h4>
        <p>The array is divided into segments (intervals).</p>
        <p>Each node of the tree stores information (like sum or min) about a segment.</p>
        <p>Queries are answered by combining results from relevant segments.</p>

        <h4>Applications:</h4>
        <ul>
            <li>Competitive programming problems (range queries).</li>
            <li>Range Sum Queries (RSQ).</li>
            <li>Minimum/Maximum in a subarray.</li>
            <li>Used in game leaderboards, stock price analysis, and data analytics.</li>
        </ul>
    </div>
</div>

    <div id="wednesday-content-week4" class="day-content day-section">
        <h2>Syntax Snapshots Wednesday</h2>
    <div class="content-block">
        <h3>Comparison of Linked Lists</h3>

        <h4>Singly Linked List:</h4>
        <ul>
            <li>Node structure: Each node has a reference to the next node</li>
            <li>Traversal: Can only traverse in one direction</li>
            <li>Insertion/Deletion: Efficient insertion and deletion at the beginning or end</li>
            <li>Memory usage: Less memory usage due to single pointer</li>
            <li>Use cases: Dynamic memory allocation, efficient insertion/deletion</li>
        </ul>

        <h4>Doubly Linked List:</h4>
        <ul>
            <li>Node structure: Each node has references to both previous and next nodes</li>
            <li>Traversal: Can traverse in both forward and backward directions</li>
            <li>Insertion/Deletion: Efficient insertion and deletion at any position</li>
            <li>Memory usage: More memory usage due to two pointers</li>
            <li>Use cases: Efficient insertion/deletion at any position, browser history</li>
        </ul>

        <h4>Circular Linked List:</h4>
        <ul>
            <li>Node structure: Last node points back to the first node</li>
            <li>Traversal: Can traverse in a circular manner</li>
            <li>Insertion/Deletion: Efficient for implementing buffers and queues</li>
            <li>Memory usage: Similar to singly linked list</li>
            <li>Use cases: Buffers, queues, traffic simulation</li>
        </ul>

        <p>This comparison highlights the key differences and use cases for each type of linked list.</p>
    </div>
    </div>

   <div id="thursday-content-week4" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <h3>Linked List in Data Structures</h3>
        <p>A Linked List is a linear data structure where elements (called nodes) are connected using pointers. Each node contains:</p>
        <ul>
            <li><strong>Data</strong> → stores the value</li>
            <li><strong>Pointer</strong> → stores the address of the next node</li>
        </ul>
        <p>Unlike arrays, linked lists don’t require continuous memory, making insertion and deletion more efficient.</p>

        <h4>Types of Linked Lists:</h4>
        <ol>
            <li><strong>Singly Linked List</strong> → Each node points to the next node only.</li>
            <li><strong>Doubly Linked List</strong> → Each node has two pointers: one to the next and one to the previous node.</li>
            <li><strong>Circular Linked List</strong> → The last node connects back to the first node, forming a circle.</li>
            <li><strong>Doubly Circular Linked List</strong> → Combines circular and bidirectional traversal.</li>
        </ol>
    </div>
</div>
    <div id="friday-content-week4" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Doubly Linked List (DLL)</h3>

        <h4>Definition:</h4>
        <p>A Doubly Linked List is a type of linked list where each node contains:</p>
        <ul>
            <li><strong>data</strong> → The actual value</li>
            <li><strong>prev</strong> → Pointer to the previous node</li>
            <li><strong>next</strong> → Pointer to the next node</li>
        </ul>
        <p>This allows bi-directional traversal (forward & backward).</p>

        <h4>Basic Operations in DLL:</h4>
        <ol>
            <li><strong>Insertion</strong>
                <ul>
                    <li>At the beginning</li>
                    <li>At the end</li>
                    <li>After a given node</li>
                </ul>
            </li>
            <li><strong>Deletion</strong>
                <ul>
                    <li>From the beginning</li>
                    <li>From the end</li>
                    <li>A given node</li>
                </ul>
            </li>
            <li><strong>Traversal</strong>
                <ul>
                    <li>Forward (head → tail)</li>
                    <li>Backward (tail → head)</li>
                </ul>
            </li>
        </ol>

        <h4>C Program (Basic DLL with Insert at Beginning, Insert at End, Forward Traversal):</h4>
        <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure of a node
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};


// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

// Insert at the beginning
void insertAtBeginning(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    if (*head != NULL) {
        newNode->next = *head;
        (*head)->prev = newNode;
    }
    *head = newNode;
}


// Insert at the end
void insertAtEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}


// Traverse forward
void displayForward(struct Node* head) {
    struct Node* temp = head;
    printf("Forward Traversal: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head = NULL;

    insertAtBeginning(&head, 10);
    insertAtBeginning(&head, 5);
    insertAtEnd(&head, 20);

    displayForward(head);

    return 0;
}</code></pre>
<h4>Output:</h4>
<code>Forward Traversal: 5 10 20</code>

        <h4>Complexities:</h4>
        <ul>
            <li><strong>Insertion/Deletion:</strong> O(1) (if position is known)</li>
            <li><strong>Traversal:</strong> O(n)</li>
            <li><strong>Space Complexity:</strong> O(n) (due to extra pointer prev)</li>
        </ul>

        <h4>Pros:</h4>
        <ol>
            <li>Can traverse in both directions</li>
            <li>Easy deletion of a given node</li>
        </ol>

        <h4>Cons:</h4>
        <ol>
            <li>Extra memory required for prev pointer</li>
            <li>Slightly more complex than singly linked list</li>
        </ol>

        <h4>Practice Task:</h4>
        <p>Extend the above program to add:</p>
        <ol>
            <li>Delete from beginning</li>
            <li>Delete from end</li>
            <li>Backward traversal</li>
        </ol>
    </div>
</div>

    <div id="saturday-content-week4" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. In a Circular Linked List, the last node points to:</h3>
        <ol>
            <li>a) NULL</li>
            <li>b) The previous node</li>
            <li><strong>c) The head (first node)</strong></li>
            <li>d) Random node</li>
        </ol>

        <h3>2. You are given an array of size n. You need to answer multiple queries of the form: Find the sum of elements from index L to R. Which data structure is most efficient for this task?</h3>
        <ol>
            <li>A) Stack</li>
            <li>B) Queue</li>
            <li><strong>C) Segment Tree</strong></li>
            <li>D) Linked List</li>
        </ol>

        <h3>3. What is the primary advantage of a Linked List over an array?</h3>
        <ol>
            <li>A. Linked lists are a type of data structure, while arrays are not.</li>
            <li>B. Linked lists use pointers, whereas arrays do not.</li>
            <li>C. Linked lists store elements in continuous memory, which arrays do not.</li>
            <li><strong>D. Linked lists do not require continuous memory, making insertion and deletion more efficient.</strong></li>
        </ol>

        <h3>4. Which type of linked list is characterized by having each node reference both the previous and the next node, allowing for traversal in two directions?</h3>
        <p><strong>Answer:</strong> Doubly Linked List</p>

        <h3>5. What is a key advantage of a doubly linked list over a singly linked list?</h3>
        <ol>
            <li>A) Less memory usage</li>
            <li><strong>B) Efficient insertion/deletion at any position</strong></li>
            <li>C) Circular traversal</li>
            <li>D) Dynamic memory allocation</li>
        </ol>
    </div>
</div>
</div>

        <!--  <p style="text-align: center; font-style: italic; color: #555;">Content coming soon!</p> -->

        <div id="week5" class="week-content">
            <!-- <p style="text-align: center; font-weight: bold; font-size: 1.5em; color: #00408f; padding: 50px;">
                Week 5 Content - COMING SOON!
            </p> -->

<p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 5 - Stacks and Queues
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week5', this, 'week5')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week5', this, 'week5')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week5', this, 'week5')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week5', this, 'week5')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week5', this, 'week5')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week5', this, 'week5')">Saturday</button>
    </div>


    <div id="monday-content-week5" class="day-content day-section">
    <h2>Monday Maverick</h2>
    <div class="content-block">
        <h4>Stack in DSA:-</h4>
        <p>Linear data structure following <strong>LIFO (Last In, First Out)</strong>.</p>
        
        <h4>Operations:</h4>
        <ul>
            <li>Push → insert</li>
            <li>Pop → remove</li>
            <li>Peek/Top → view top element</li>
        </ul>

        <h4>Use Cases</h4>
        <ul>
            <li>Function call (call stack)</li>
            <li>Undo/Redo (editors)</li>
            <li>Expression evaluation (infix → postfix)</li>
            <li>Balanced parentheses checking</li>
            <li>Backtracking (mazes, puzzles)</li>
            <li>Browser history (Back button)</li>
            <li>Recursion & memory management</li>
        </ul>
    </div>
</div>

<div id="tuesday-content-week5" class="day-content day-section">
    <h2>Techie Tuesday</h2>
    <div class="content-block">
        <h3>Stack in Data Structures</h3>

        <h4>What is a Stack?</h4>
        <p>A stack is a linear data structure that follows the <strong>LIFO</strong> principle (Last In, First Out).</p>
        <p>Example in real life: Stack of plates/books → The last one placed is the first one removed.</p>

        <h4>Main Operations</h4>
        <ol>
            <li><strong>Push</strong> → Add an element on top of the stack</li>
            <li><strong>Pop</strong> → Remove the top element from the stack</li>
            <li><strong>Peek/Top</strong> → View the top element without removing it</li>
            <li><strong>isEmpty</strong> → Check if the stack has no elements</li>
        </ol>


        <h4>Characteristics</h4>
        <ul>
            <li><strong>Order:</strong> LIFO (Last In, First Out)</li>
            <li><strong>Access:</strong> Only the top element is accessible directly</li>
            <li><strong>Efficiency:</strong> Both push and pop take O(1) time</li>
        </ul>

        <h4>Implementation Methods</h4>
        <ol>
            <li>
                <strong>Using Array</strong>
                <ul>
                    <li>Easy to implement</li>
                    <li>Fixed size (may cause overflow)</li>
                </ul>
            </li>
            <li>
                <strong>Using Linked List</strong>
                <ul>
                    <li>Dynamic size (grows/shrinks as needed)</li>
                    <li>Needs extra memory for pointers</li>
                </ul>
            </li>
        </ol>
        <h4>Applications of Stack</h4>
        <ul>
            <li>Undo/Redo operations in editors</li>
            <li>Browser back/forward navigation</li>
            <li>Expression evaluation (postfix, prefix)</li>
            <li>Function call management (recursion uses stack)</li>
            <li>Balancing symbols (like brackets in code)</li>
        </ul>

        <h4>Program:</h4>
        <pre><code>#include &lt;iostream&gt;
using namespace std;
#define SIZE 5

class Stack {
    int arr[SIZE], top;
public:
    Stack() { top = -1; }

    void push(int x) {
        if (top == SIZE - 1) cout << "Overflow\n";
        else arr[++top] = x;
    }

    void pop() {
        if (top == -1) cout << "Underflow\n";
        else cout << arr[top--] << " popped\n";
    }

    void peek() {
        if (top == -1) cout << "Empty\n";
        else cout << "Top = " << arr[top] << endl;
    }
};

int main() {
    Stack s;
    s.push(10);
    s.push(20);
    s.peek();
    s.pop();
    s.peek();
}</code></pre>
<h4>Output:</h4>
<code>Top = 20
20 popped
Top = 10</code>
    </div>
</div>

   <div id="wednesday-content-week5" class="day-content day-section">
    <h2>Syntax Snapshots Wednesday</h2>
    <div class="content-block">
        <h3>Queue (FIFO)</h3>

        <h4>Definition:</h4>
        <p>A Queue is a linear data structure that works on the principle of <strong>FIFO (First In, First Out)</strong>. Think of it like a line at a ticket counter – the first person who enters is the first to leave.</p>

        <h4>Queue Operations:</h4>
        <ol>
            <li><strong>Enqueue</strong> Insert element at the rear</li>
            <li><strong>Dequeue</strong> Remove element from the front</li>
            <li><strong>Peek/Front</strong> Get the front element without removing it</li>
            <li><strong>IsEmpty</strong> Check if queue is empty</li>
            <li><strong>IsFull</strong> Check if queue is full (in array implementation)</li>
        </ol>

        <h4>C Program – Queue using Array:</h4>
        <pre><code>#include &lt;stdio.h&gt;
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

// Enqueue operation
void enqueue(int data) {
    if (rear == MAX - 1) {
        printf("Queue Overflow\n");
    } else {
        if (front == -1) front = 0;
        queue[++rear] = data;
        printf("%d enqueued\n", data);
    }
}

// Dequeue operation
void dequeue() {
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
    } else {
        printf("%d dequeued\n", queue[front++]);
    }
}

// Peek operation
void peek() {
    if (front == -1 || front > rear) {
        printf("Queue is empty\n");
    } else {
        printf("Front element: %d\n", queue[front]);
    }
}

// Display operation
void display() {
    if (front == -1 || front > rear) {
        printf("Queue is empty\n");
    } else {
        printf("Queue elements: ");
        for (int i = front; i <= rear; i++) {
            printf("%d ", queue[i]);
        }
        printf("\n");
    }
}

int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    display();
    peek();
    dequeue();
    display();
    return 0;
}
</code></pre>

        <h4>Complexities:</h4>
        <ul>
            <li>Enqueue: O(1)</li>
            <li>Dequeue: O(1)</li>
            <li>Peek: O(1)</li>
            <li>Display: O(n)</li>
        </ul>

        <h4>Pros:</h4>
        <ul>
            <li>Simple and useful in scheduling (like CPU jobs)</li>
            <li>Ensures fairness (FIFO order)</li>
        </ul>
    </div>
</div>

<div id="thursday-content-week5" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <h4>Circular Queue</h4>
        <p>A type of queue where the last position is connected back to the first, forming a circle.</p>
        <p>Solves the problem of unused space in a linear queue.</p>
        <p>Operations: Enqueue, Dequeue, Front, Rear</p>

        <h4>Deque (Double-Ended Queue)</h4>
        <p>A queue where insertion and deletion can happen from both ends.</p>
        
        <h4>Types:</h4>
        <ul>
            <li>Input Restricted Deque (deletion at both ends, insertion at one end)</li>
            <li>Output Restricted Deque (insertion at both ends, deletion at one end)</li>
        </ul>

        <h4>Use cases:</h4>
        <p>Circular Queue: CPU scheduling, memory management.</p>
        <p>Deque: Palindrome checking, sliding window problems.</p>

        <p>Master these to level up your Data Structures & Algorithms skills!</p>
    </div>
</div>

<div id="friday-content-week5" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Applications of Stacks</h3>

        <p>Stacks have numerous applications in computer science, particularly in evaluating expressions and implementing recursion.</p>

        <h4>Expressions Evaluation</h4>
        <ul>
            <li><strong>Description:</strong> Stacks can be used to evaluate postfix expressions, also known as Reverse Polish Notation (RPN). In postfix notation, operators follow their operands.</li>
            <li><strong>Example:</strong> Evaluate the expression <strong>3 4 + 2 *</strong>. Using a stack, we can push the operands <strong>3</strong> and <strong>4</strong> onto the stack, then encounter the <strong>+</strong> operator, which pops the top two elements, adds them, and pushes the result <strong>7</strong> onto the stack. Next, we push <strong>2</strong> onto the stack and encounter the <strong>*</strong> operator, which pops the top two elements, multiplies them, and pushes the result <strong>14</strong> onto the stack.</li>
            <li><strong>Explanation:</strong> Stacks are useful for evaluating postfix expressions because they allow us to efficiently manage the order of operations and handle nested expressions.</li>
        </ul>

        <h4>Recursion using Stack</h4>
        <ul>
            <li><strong>Description:</strong> Stacks can be used to implement recursive functions iteratively. By pushing function calls onto a stack, we can mimic the recursive call stack.</li>
            <li><strong>Example:</strong> Consider a recursive function to calculate the factorial of a number <strong>n</strong>. We can implement this using a stack by pushing the numbers <strong>n</strong> to <strong>1</strong> onto the stack, then popping each number off the stack and multiplying it with the result.</li>
            <li><strong>Explanation:</strong> Using a stack to implement recursion can help avoid the overhead of recursive function calls and reduce the risk of stack overflow errors.</li>
        </ul>

        <h4>Benefits</h4>
        <ul>
            <li><strong>Efficient evaluation:</strong> Stacks allow for efficient evaluation of postfix expressions and recursive functions.</li>
            <li><strong>Flexibility:</strong> Stacks can be used to implement a wide range of algorithms and data structures.</li>
        </ul>

        <h4>Code Examples</h4>
        <p>Here are some code examples in C to demonstrate the use of stacks for expression evaluation and recursion:</p>
        <pre><code>// Postfix expression evaluation
int evaluate_postfix(char* expression) {
    int stack[100];
    int top = -1;

    for (int i = 0; expression[i]; i++) {
        if (isdigit(expression[i])) {
            stack[++top] = expression[i] - '0';
        } else if (expression[i] == '+') {
            int operand2 = stack[top--];
            int operand1 = stack[top--];
            stack[++top] = operand1 + operand2;
        } else if (expression[i] == '*') {
            int operand2 = stack[top--];
            int operand1 = stack[top--];
            stack[++top] = operand1 * operand2;
        }
    }

    return stack[top];
}

// Recursion using stack
int factorial(int n) {
    int stack[100];
    int top = -1;

    for (int i = n; i >= 1; i--) {
        stack[++top] = i;
    }

    int result = 1;
    while (top >= 0) {
        result *= stack[top--];
    }

    return result;
}</code></pre>
        <p>These code examples demonstrate the use of stacks of evaluating postfix expressions and implementing recursive functions iteratively.</p>
    </div>
</div>

    <div id="saturday-content-week5" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. Which of the following real-world scenarios is most effectively modeled using a stack data structure?</h3>
        <ol>
            <li>A) The flow of traffic at a one-way intersection.</li>
            <li>B) The line of customers waiting at a checkout counter.</li>
            <li><strong>C) The undo/redo functionality in a text editor.</strong></li>
            <li>D) A playlist that shuffles songs randomly.</li>
        </ol>

        <h3>2. Which principle does a Stack data structure follow?</h3>
        <ol>
            <li>A) First-In, First-Out (FIFO)</li>
            <li>B) Last-In, Last-Out (LILO)</li>
            <li>C) First-In, Last-Out (FILO)</li>
            <li><strong>D) Last-In, First-Out (LIFO)</strong></li>
        </ol>

        <h3>3. What is the correct action for the enqueue operation?</h3>
        <ol>
            <li>A) Removing an element from the front of the queue.</li>
            <li>B) Getting the value of the front element without removing it.</li>
            <li><strong>C) Inserting a new element at the rear of the queue.</strong></li>
            <li>D) Checking if the queue is empty.</li>
        </ol>

        <h3>4. What is the primary difference between a stack and a queue?</h3>
        <ol>
            <li>A) Stacks are used for storing data, while queues are not.</li>
            <li><strong>B) Stacks follow a Last-In, First-Out (LIFO) principle, while queues follow a First-In, First-Out (FIFO) principle.</strong></li>
            <li>C) Stacks can only store numbers, while queues can store any data type.</li>
            <li>D) Stacks are dynamic data structures, while queues are static.</li>
        </ol>

        <h3>5. Which of the following scenarios is most effectively handled by a stack data structure?</h3>
        <ol>
            <li>A) Storing a list of people in a queue waiting to be served.</li>
            <li><strong>B) Keeping track of the history of visited web pages in a web browser to enable a "back" button.</strong></li>
            <li>C) Managing a circular list of tasks that repeat in a loop.</li>
            <li>D) Storing a student's ID and name for quick, random access.</li>
        </ol>
    </div>
</div>
</div>

<div id="week6" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 6 - Trees and Graphs (Basics)
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week6', this, 'week6')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week6', this, 'week6')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week6', this, 'week6')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week6', this, 'week6')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week6', this, 'week6')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week6', this, 'week6')">Saturday</button>
    </div>
    
<div id="monday-content-week6" class="day-content day-section">
    <h2>Monday Maverick</h2>
    <div class="content-block">
        <h3>Trees and graphs</h3>

        <h4>Tree in DSA</h4>
        <p>Hierarchical structure (like a family tree).</p>
        <p>Root (top), Leaf (end), Parent–Child, Siblings, Height, Level, Subtree.</p>

        <h4>Binary Tree</h4>
        <p>Each node has at most 2 children → Left & Right.</p>
        
        <h4>Types:</h4>
        <ul>
            <li>Full → 0 or 2 kids</li>
            <li>Complete → filled level-wise</li>
            <li>Perfect → all leaves at same level</li>
            <li>Skewed → one-sided</li>
        </ul>

        <h4>Binary Search Tree (BST)</h4>
        <p>Special Binary Tree with ordered property:</p>
        <p>Left < Root < Right</p>
        <p>Inorder traversal = sorted list</p>
        <p>Fast search, insert, delete (O(log n) if balanced).</p>

        <h4>In short:</h4>
        <ul><li>Tree = hierarchy</li>
        <li>Binary Tree = max 2 children</li>
        <li>BST = sorted binary tree</li></ul>
    </div>
</div>

<div id="tuesday-content-week6" class="day-content day-section">
    <h2>Techie Tuesday</h2>
    <div class="content-block">
        <h3>BST OPERATIONS</h3>
        
        <h4>Binary Search:</h4>
        <p>Binary Search is an efficient searching algorithm that works on a sorted list by repeatedly dividing the search interval in half until the target element is found or the interval becomes empty.</p>
        
        <h4>Simple BST Program</h4>
        <p><strong>Code:</strong></p>
        <pre><code>    def __init__(self, key):
        self.key = key      # value of node
        self.left = None    # left child
        self.right = None   # right child

# INSERT operation
def insert(root, key):
    if root is None:              # if tree is empty
        return Node(key)
    if key < root.key:              # smaller → go left
        root.left = insert(root.left, key)
    elif key > root.key:             # larger → go right
        root.right = insert(root.right, key)
    return root

# SEARCH operation
def search(root, key):
    if root is None:              # not found
        return None
    if root.key == key:            # found
        return root
    if key < root.key:              # search left
        return search(root.left, key)
    return search(root.right, key)  # search right

# DELETE operation
def delete(root, key):
    if root is None:
        return root
    if key < root.key:              # go left
        root.left = delete(root.left, key)
    elif key > root.key:             # go right
        root.right = delete(root.right, key)
    else:  # found node to delete
        if root.left is None:      # 1 child or no child
            return root.right
        elif root.right is None:
            return root.left
        # 2 children → find min in right subtree
        temp = root.right
        while temp.left:
            temp = temp.left
        root.key = temp.key
        root.right = delete(root.right, temp.key)
    return root</code></pre>

        <h4>---------------- Example ----------------</h4>
        <pre><code>root = None
# Insert values
for val in [50, 30, 70, 20, 40, 60, 80]:
    root = insert(root, val)

print("Search 40:", "Found" if search(root, 40) else "Not Found")

root = delete(root, 20)    # Delete leaf
root = delete(root, 30)    # Delete node with one child
root = delete(root, 50)    # Delete node with two children</code></pre>

        <h4>Explanation</h4>
        <p><strong>Insert →</strong> If new value is smaller → go left; if bigger → go right; if empty → create new node.</p>
        <p><strong>Search →</strong> Compare with root: if equal → found; if smaller → go left; if bigger → go right.</p>
        <p><strong>Delete</strong></p>
        <ol>
            <li>If node has no child → just remove it.</li>
            <li>If node has one child → replace with that child.</li>
            <li>If node has two children → replace with the smallest value in right subtree.</li>
        </ol>
    </div>
</div>

<div id="wednesday-content-week6" class="day-content day-section">
    <h2>Syntax Snapshots Wednesday</h2>
    <div class="content-block">
        <h3>Tree Traversals</h3>

        <h4>Definition:</h4>
        <p>Tree Traversal means visiting each node of a tree exactly once in a specific order.</p>

        <p>There are 3 main Depth-First Traversals (DFS):</p>

        <h4>1. Inorder (L → Root → R)</h4>
        <p>Visit Left subtree, then Root, then Right subtree</p>
        <p>For Binary Search Tree (BST), Inorder traversal gives elements in sorted order</p>

        <h4>2. Preorder (Root → L → R)</h4>
        <p>Visit Root first, then Left subtree, then Right subtree</p>
        <p>Useful for creating a copy of a tree or prefix expression notation</p>

        <h4>3. Postorder (L → R → Root)</h4>
        <p>Visit Left subtree, then Right subtree, then Root</p>
        <p>Useful for deleting/freeing the tree, or postfix expression evaluation</p>

        <h4>C Program – Tree Traversals</h4>
        <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure of a tree node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Inorder Traversal
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Preorder Traversal
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder Traversal
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

int main() {
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    printf("Inorder Traversal: ");
    inorder(root);
    printf("\n");

    printf("Preorder Traversal: ");
    preorder(root);
    printf("\n");

    printf("Postorder Traversal: ");
    postorder(root);
    printf("\n");

    return 0;
}
</code></pre>
<h4>Output:</h4>
<code>Inorder Traversal: 4 2 5 1 3
Preorder Traversal: 1 2 4 5 3
Postorder Traversal: 4 5 2 3 1</code>

        <h4>Time Complexity:</h4>
        <p>O(n) (all nodes are visited once)</p>

        <h4>Space Complexity:</h4>
        <p>O(h) (h = height of tree, due to recursion stack)</p>

        <h4>Use Cases:</h4>
        <p>Inorder → Sorted traversal in BST<br>Preorder → Tree construction / Expression trees<br>Postorder → Deleting tree / Expression evaluation</p>
    </div>
</div>

   <div id="thursday-content-week6" class="day-content day-section">
    <h2>Te Ta Thursday</h2>
    <div class="content-block">
        <p>At its core, Data Structures and Algorithms (DSA) is a fundamental concept in computer science that deals with two key aspects:</p>
        <ul>
            <li>
                <strong>Data Structures:</strong> These are specific ways of organizing and storing data in a computer so that it can be accessed and used efficiently. Think of them as different types of containers, each with its own strengths and weaknesses depending on what you need to do. Common examples include:
                <ul>
                    <li>Arrays: A simple list of items.</li>
                    <li>Linked Lists: A chain of items.</li>
                    <li>Stacks: A pile of items where you can only access the top one (Last-In, First-Out).</li>
                    <li>Queues: A line of items where the first one in is the first one out (First-In, First-Out).</li>
                    <li>Trees: A hierarchical structure, like a family tree or a file system.</li>
                    <li>Graphs: A network of connected items, like a social network.</li>
                    <li>Hash Tables: A way to store and retrieve items very quickly using a key.</li>
                </ul>
            </li>
            <li>
                <strong>Algorithms:</strong> These are a set of step-by-step instructions or rules that are designed to solve a specific problem or perform a particular task. In the context of DSA, algorithms are often used to manipulate the data within the data structures. For example, you might have an algorithm to:
                <ul>
                    <li>Search for a specific item in a data structure.</li>
                    <li>Sort the items in a data structure into a particular order.</li>
                    <li>Insert a new item into a data structure.</li>
                    <li>Delete an item from a data structure.</li>
                </ul>
            </li>
        </ul>
        <p>In simple terms:</p>
        <p>Imagine you have a large library of books (the data).</p>
        <ul>
            <li>A data structure is how you choose to organize those books. You could stack them in a single pile (a stack), line them up on a long shelf (an array), or create a card catalog with references to where each book is (a hash table).</li>
            <li>An algorithm is the set of instructions you follow to find a specific book. For a pile of books, your algorithm would be to take them off one by one until you find the one you're looking for. For the card catalog, your algorithm would be to look up the book's reference and go directly to its location.</li>
        </ul>
        <p>Why is DSA important?</p>
        <p>The choice of data structure and algorithm can have a huge impact on the efficiency of a computer program. A well-chosen combination can make a program run much faster and use less memory, which is crucial for building complex and scalable software. Understanding DSA is therefore a fundamental skill for any programmer.</p>
    </div>
</div>

    <div id="friday-content-week6" class="day-content day-section">
    <h2>Function Friday</h2>
    <div class="content-block">
        <h3>Graph Representation</h3>
        <p>A graph is a non-linear data structure consisting of nodes or vertices connected by edges. There are two primary ways to represent graphs:</p>
        
        <h4>1. Adjacency Matrix</h4>
        <ul>
            <li><strong>Description:</strong> An adjacency matrix is a square matrix where the entry at row `i` and column `j` represents the weight of the edge between vertices `i` and `j`.</li>
            <li><strong>Example:</strong> Consider a graph with vertices `A`, `B`, `C`, and `D`. The adjacency matrix for this graph would be a 4x4 matrix, where the entry at row `A` and column `B` represents the weight of the edge between `A` and `B`.</li>
            <li><strong>Explanation:</strong> Adjacency matrices are useful for dense graphs, where most vertices are connected to each other. However, they can be memory-inefficient for sparse graphs.</li>
        </ul>
        
        <h4>2. Adjacency List</h4>
        <ul>
            <li><strong>Description:</strong> An adjacency list is a collection of lists, where each list represents the vertices adjacent to a particular vertex.</li>
            <li><strong>Example:</strong> Consider a graph with vertices `A`, `B`, `C`, and `D`. The adjacency list for this graph would be a list of vertices, where each vertex is associated with a list of its adjacent vertices.</li>
            <li><strong>Explanation:</strong> Adjacency lists are useful for sparse graphs, where most vertices are not connected to each other. They can be more memory-efficient than adjacency matrices.</li>
        </ul>
        
        <h3>Graph Traversal Algorithms</h3>
        <p>Graph traversal algorithms are used to visit vertices in a graph. Two common graph traversal algorithms are:</p>
        
        <h4>1. Breadth-First Search (BFS)</h4>
        <ul>
            <li><strong>Description:</strong> BFS is a graph traversal algorithm that visits vertices in a breadthward motion, exploring all vertices at a given depth before moving to the next depth level.</li>
            <li><strong>Example:</strong> Consider a graph with vertices `A`, `B`, `C`, and `D`, where `A` is connected to `B` and `C`, and `B` is connected to `D`. A BFS traversal starting from `A` would visit vertices in the order `A`, `B`, `C`, `D`.</li>
            <li><strong>Explanation:</strong> BFS is useful for finding shortest paths in unweighted graphs.</li>
        </ul>
        
        <h4>2. Depth-First Search (DFS)</h4>
        <ul>
            <li><strong>Description:</strong> DFS is a graph traversal algorithm that visits vertices in a depthward motion, exploring as far as possible along each branch before backtracking.</li>
            <li><strong>Example:</strong> Consider a graph with vertices `A`, `B`, `C`, and `D`, where `A` is connected to `B` and `C`, and `B` is connected to `D`. A DFS traversal starting from `A` might visit vertices in the order `A`, `B`, `D`, `C`.</li>
            <li><strong>Explanation:</strong> DFS is useful for detecting cycles in graphs and for topological sorting.</li>
        </ul>
        
        <p>These graph traversal algorithms have numerous applications in computer science, including finding shortest paths, detecting cycles, and solving graph-related problems.</p>
    </div>
</div>
   <div id="saturday-content-week6" class="day-content day-section">
    <h2>Brain Cache</h2>
    <div class="content-block">
        <h3>1. A data structure where each node can have at most two children is known as what?</h3>
        <ol>
            <li>A) A Full Tree</li>
            <li>B) A Complete Tree</li>
            <li><strong>C) A Binary Tree</strong></li>
            <li>D) A Skewed Tree</li>
        </ol>

        <h3>2. In the context of a hash table, what is a "collision"?</h3>
        <ol>
            <li>A) A situation where the hash table's capacity has been reached.</li>
            <li><strong>B) When two or more different keys compute to the same hash value, leading to the same index in the table.</strong></li>
            <li>C) A failed attempt to insert an element into the table.</li>
            <li>D) The process of finding an element in a hash table.</li>
        </ol>

        <h3>3. The following C program creates a binary tree with the numbers 1, 2, 3, 4, and 5. What will be the output of the provided C program's postorder traversal function?</h3>
        <p>The tree is constructed as follows:<br>1 is the root.<br>2 is the left child of 1.<br>3 is the right child of 1.<br>4 is the left child of 2.<br>5 is the right child of 2.</p>
        <pre><code>void postorderTraversal(struct Node* root) {
if (root != NULL) {
postorderTraversal(root->left);
postorderTraversal(root->right);
printf("%d ", root->data);
}
}
</code></pre>
        <ol>
            <li><strong>A) 4 5 2 3 1</strong></li>
            <li>B) 1 2 4 5 3</li>
            <li>C) 4 2 5 1 3</li>
            <li>D) 1 2 3 4 5</li>
        </ol>

        <h3>4. Which of the following data structures is best suited for an application that needs to manage a list of tasks in the order they are received, ensuring the oldest task is always processed first?</h3>
        <ol>
            <li>A) Stack</li>
            <li><strong>B) Queue</strong></li>
            <li>C) Array</li>
            <li>D) Hash Table</li>
        </ol>

        <h3>5. What is the primary advantage of using Breadth-First Search (BFS) over Depth-First Search (DFS) when finding the shortest path in an unweighted graph?</h3>
        <ol>
            <li>A) BFS uses less memory than DFS.</li>
            <li><strong>B) BFS is guaranteed to find the shortest path.</strong></li>
            <li>C) DFS can get stuck in an infinite loop on cyclic graphs.</li>
            <li>D) BFS is more efficient for dense graphs.</li>
        </ol>
    </div>
</div>
</div>  

<div id="week7" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 7 - Brainstorming Part-1
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week7', this, 'week7')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week7', this, 'week7')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week7', this, 'week7')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week7', this, 'week7')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week7', this, 'week7')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week7', this, 'week7')">Saturday</button>
    </div>
    
    <div id="monday-content-week7" class="day-content day-section">
        <h2>Monday Maverick</h2>
        <div class="quiz-container">
        <h3>Questions:</h3>
    <div class="question-block">
        <p>1. Which of the following data structures is best suited for implementing recursion?</p>
        <div class="options">
            <div class="quiz-option" data-question="q1" data-value="a">A. Queue;</div>
            <div class="quiz-option" data-question="q1" data-value="b">B. Stack</div>
            <div class="quiz-option" data-question="q1" data-value="c">C. Linked list</div>
            <div class="quiz-option" data-question="q1" data-value="d">D. Tree</div>
        </div>
        <div class="quiz-feedback"></div>
    </div>

    </div></div>

    <div id="tuesday-content-week7" class="day-content day-section">
        <h2>Techie Tuesday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="wednesday-content-week7" class="day-content day-section">
        <h2>Syntax Snapshots Wednesday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="thursday-content-week7" class="day-content day-section">
        <h2>Te Ta Thursday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="friday-content-week7" class="day-content day-section">
        <h2>Function Friday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>
   <div id="saturday-content-week7" class="day-content day-section">
        <h2>Brain Cache</h2>
        <div class="content-block">
            <center><p>Week 7 Quiz coming soon!</p>
<!--<p>Quiz answers will be uploaded soon!</p>-->
           <button onclick="window.location.href='https://thecodersclub-mce.github.io/dsa/quiz.html'">
    Week 7 Quiz
</button></center>
        </div>
    </div>
</div> 

<div id="week8" class="week-content">
    <p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">
        Content for Week 8 - Brainstorming Part-2
    </p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week8', this, 'week8')">Monday</button>
        <button class="tab-button" onclick="showDay('tuesday-content-week8', this, 'week8')">Tuesday</button>
        <button class="tab-button" onclick="showDay('wednesday-content-week8', this, 'week8')">Wednesday</button>
        <button class="tab-button" onclick="showDay('thursday-content-week8', this, 'week8')">Thursday</button>
        <button class="tab-button" onclick="showDay('friday-content-week8', this, 'week8')">Friday</button>
        <button class="tab-button" onclick="showDay('saturday-content-week8', this, 'week8')">Saturday</button>
    </div>
    
    <div id="monday-content-week8" class="day-content day-section">
        <h2>Monday Maverick</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="tuesday-content-week8" class="day-content day-section">
        <h2>Techie Tuesday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="wednesday-content-week8" class="day-content day-section">
        <h2>Syntax Snapshots Wednesday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="thursday-content-week8" class="day-content day-section">
        <h2>Te Ta Thursday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>

    <div id="friday-content-week8" class="day-content day-section">
        <h2>Function Friday</h2>
        <div class="content-block">
            <p>Content coming soon!</p>
        </div>
    </div>
   <div id="saturday-content-week8" class="day-content day-section">
        <h2>Brain Cache</h2>
        <div class="content-block">
            
            <center><p>Week 8 Quiz coming soon!</p>
<!--<p>Quiz answers will be uploaded soon!</p>-->
            <button onclick="window.location.href='https://thecodersclub-mce.github.io/dsa/quiz.html'">
    Week 8 Quiz
</button></center>
        </div>
    </div>
</div><!-- add week8 content before these -->  
<div id="week10" class="week-content">
<p style="text-align: left; font-weight: bold; font-size: 18px; margin-bottom: 10px; color: #00408f;">Mindmash</p>
    <div class="nested-tab-nav">
        <button class="tab-button" onclick="showDay('monday-content-week10', this, 'week10')">Quiz 1</button>
    </div>

    <div id="monday-content-week10" class="day-content day-section">
        <h2>Mindmash - Quiz 1 Coming Soon!</h2>
    </div>
</div><!-- Mindmash content before this-->

</div><!-- content-container-wrapper closing-->

    <footer>
        <p>Created by The Coders Club</p>
        <a href="https://www.instagram.com/the_mce.coders_club?igsh=Z245eDZmdWhkcmRn" target="_blank">
            <img src="IG.png" alt="Instagram" class="social-logo">
        </a>
        <a href="https://www.linkedin.com/in/thecodersclub-mce/" target="_blank">
            <img src="LINKEDLN.png" alt="LinkedIn" class="social-logo">
        </a>
        <a href="https://www.youtube.com/@TheCodersClub_MCE" target="_blank">
            <img src="YT.png" alt="YouTube" class="social-logo">
        </a>
        <a href="https://whatsapp.com/channel/0029Vb6HMGKKAwEe8OdjAF0X" target="_blank">
            <img src="WP.svg" alt="WhatsApp" class="social-logo">
        </a>
    </footer>

<script>
// --- CONTROL KEYWORD HERE ---
// Define a constant array of all enabled weeks.
// Any week not listed here will be treated as disabled.
const enabledWeeks = [
    'week1', 'week2', 'week3', 'week4', 'week5',
    'week6', 'week7', 'week8', 'week9', 'week10', 'week11'
];

// Define an array of disabled days for a given week.
const disabledDays = {
   // 'week1': [],
   //'week2': ['monday','tuesday','wednesday','thursday','friday'],
   // 'week3': [],
   // 'week4': [],
   // 'week5': [],
   // 'week6': [],
   // 'week7': [],
};
// --- END CONTROL KEYWORD ---

// Object to store original text content for jumbling/unjumbling
const originalTextStore = {};

// Function to shuffle characters in a string
function shuffleString(str) {
    let a = str.split("");
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a.join("");
}

// Function to jumble the text content of an element
function jumbleText(element) {
    if (element && element.textContent && element.textContent.trim().length > 0) {
        const elementKey = element.id || 'jumble-' + Math.random().toString(36).substring(2, 9);
        if (!element.id) {
            element.id = elementKey;
        }

        if (!originalTextStore[elementKey]) {
            originalTextStore[elementKey] = element.textContent;
        }
        element.textContent = shuffleString(element.textContent);
    }
}

// Function to unjumble the text content of an element
function unjumbleText(element) {
    if (element && element.id && originalTextStore[element.id]) {
        element.textContent = originalTextStore[element.id];
    }
}

// Function to show content for a specific week
function showWeek(weekId, clickedButton) {
    const isWeekEnabled = enabledWeeks.includes(weekId);

    const weekContents = document.querySelectorAll('.week-content');
    weekContents.forEach(content => {
        content.classList.remove('active-content');
        content.classList.remove('content-disabled-overlay');
    });

    const mainTabButtons = document.querySelectorAll('.main-tab-nav .tab-button');
    mainTabButtons.forEach(button => {
        button.classList.remove('active');
    });

    const selectedWeekContent = document.getElementById(weekId);
    selectedWeekContent.classList.add('active-content');

    if (clickedButton) {
        clickedButton.classList.add('active');
    }

    if (!isWeekEnabled) {
        selectedWeekContent.classList.add('content-disabled-overlay');
        selectedWeekContent.querySelectorAll('h3, p, h4, span, .quiz-option, li').forEach(element => {
            jumbleText(element);
        });

        selectedWeekContent.querySelectorAll('.nested-tab-nav .tab-button').forEach(button => {
            button.classList.remove('active');
        });

        selectedWeekContent.querySelectorAll('.day-content').forEach(content => {
            content.classList.remove('active-content');
            content.classList.add('content-disabled-overlay');
            content.querySelectorAll('h4, p, span, li, .quiz-option').forEach(element => {
                jumbleText(element);
            });
        });

    } else {
        selectedWeekContent.classList.remove('content-disabled-overlay');
        selectedWeekContent.querySelectorAll('h3, p, h4, span, .quiz-option, li').forEach(element => {
            unjumbleText(element);
        });

        const dayButtons = selectedWeekContent.querySelectorAll('.nested-tab-nav .tab-button');
        let firstAvailableDayButton = null;

        dayButtons.forEach(button => {
            const dayNameMatch = button.getAttribute('onclick').match(/showDay\('([^']+)'/);
            if (dayNameMatch) {
                const dayName = dayNameMatch[1].split('-')[0];
                if (!disabledDays[weekId] || !disabledDays[weekId].includes(dayName)) {
                    if (!firstAvailableDayButton) {
                        firstAvailableDayButton = button;
                    }
                }
            }
        });
        
        dayButtons.forEach(button => {
            const dayNameMatch = button.getAttribute('onclick').match(/showDay\('([^']+)'/);
            if (dayNameMatch) {
                const dayName = dayNameMatch[1].split('-')[0];
                if (disabledDays[weekId] && disabledDays[weekId].includes(dayName)) {
                    button.classList.add('disabled');
                    button.setAttribute('data-original-onclick', button.getAttribute('onclick'));
                    button.removeAttribute('onclick');
                } else {
                    button.classList.remove('disabled');
                    if (button.hasAttribute('data-original-onclick')) {
                        button.setAttribute('onclick', button.getAttribute('data-original-onclick'));
                        button.removeAttribute('data-original-onclick');
                    }
                }
            }
        });

        if (firstAvailableDayButton) {
            const onclickAttribute = firstAvailableDayButton.getAttribute('onclick');
            const dayIdMatch = onclickAttribute.match(/showDay\('([^']+)'/);
            if (dayIdMatch && dayIdMatch[1]) {
                const defaultDayId = dayIdMatch[1];
                showDay(defaultDayId, firstAvailableDayButton, weekId);
            } else {
                console.warn(`Could not determine default day ID for week ${weekId}.`);
            }
        } else {
            console.warn(`All days for week ${weekId} are disabled. No day content will be shown.`);
            const dayContents = selectedWeekContent.querySelectorAll('.day-content');
            dayContents.forEach(content => {
                content.classList.remove('active-content');
                content.classList.add('content-disabled-overlay');
                content.querySelectorAll('h4, p, span, li, .quiz-option').forEach(element => {
                    jumbleText(element);
                });
            });
        }
    }
}

// Function to show content for a specific day within a week
function showDay(dayIdWithWeek, clickedButton, weekId) {
    const weekContentDiv = document.getElementById(weekId);

    const dayContents = weekContentDiv.querySelectorAll('.day-content');
    dayContents.forEach(content => {
        content.classList.remove('active-content');
        content.classList.remove('content-disabled-overlay');
        content.querySelectorAll('h4, p, span, li, .quiz-option').forEach(element => {
            unjumbleText(element);
        });
    });

    const dayTabButtons = weekContentDiv.querySelectorAll('.nested-tab-nav .tab-button');
    dayTabButtons.forEach(button => {
        button.classList.remove('active');
    });

    const dayName = dayIdWithWeek.split('-')[0];

    const targetDayContent = document.getElementById(dayIdWithWeek);

    if (targetDayContent) {
        targetDayContent.classList.add('active-content');
    }

    if (clickedButton) {
        clickedButton.classList.add('active');
    }

    const isWeekEnabled = enabledWeeks.includes(weekId);
    if ((disabledDays[weekId] && disabledDays[weekId].includes(dayName)) || !isWeekEnabled) {
        if (targetDayContent) {
            targetDayContent.classList.add('content-disabled-overlay');
            targetDayContent.querySelectorAll('h4, p, span, li, .quiz-option').forEach(element => {
                jumbleText(element);
            });
        }
        if (clickedButton) {
            clickedButton.classList.add('disabled');
        }
    } else {
        if (targetDayContent) {
            targetDayContent.querySelectorAll('h4, p, span, li, .quiz-option').forEach(element => {
                unjumbleText(element);
            });
        }
        if (clickedButton) {
            clickedButton.classList.remove('disabled');
        }
    }
}

// Function to apply initial setup (handles button disabling based on enabledWeeks)
function applyInitialWeekSetup() {
    document.querySelectorAll('.main-tab-nav .tab-button').forEach(button => {
        const weekIdMatch = button.getAttribute('onclick').match(/'(week\d+)'/);
        const weekId = weekIdMatch ? weekIdMatch[1] : null;

        if (weekId && !enabledWeeks.includes(weekId)) {
            button.classList.add('disabled');
            button.setAttribute('data-original-onclick', button.getAttribute('onclick'));
            button.removeAttribute('onclick');
        } else {
            button.classList.remove('disabled');
            if (button.hasAttribute('data-original-onclick')) {
                button.setAttribute('onclick', button.getAttribute('data-original-onclick'));
                button.removeAttribute('data-original-onclick');
            }
        }
    });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    applyInitialWeekSetup();

    const hash = window.location.hash;
    let weekToShow = 'week1';

    if (hash) {
        const weekIdFromHash = hash.substring(1);
        const weekButton = document.querySelector(`.main-tab-nav button[onclick*="${weekIdFromHash}"]`);

        if (weekButton && enabledWeeks.includes(weekIdFromHash)) {
            weekToShow = weekIdFromHash;
        } else if (weekButton && !enabledWeeks.includes(weekIdFromHash)) {
            console.warn(`Attempted to link to disabled week: ${weekIdFromHash}. Showing Week 1 instead.`);
        } else {
            console.warn(`Invalid or non-existent week ID in hash: ${hash}. Showing Week 1 instead.`);
        }
    }

    const targetWeekButton = document.querySelector(`.main-tab-nav .tab-button[onclick*="${weekToShow}"]`);
    if (targetWeekButton) {
        showWeek(weekToShow, targetWeekButton);
    } else {
        console.error("Default week button not found!");
    }

    const answers = {
        'week6': {
            'monday': {
                'q1': 'c',
                'q2': 'a'
            },
            'tuesday': {
                'q1': 'b',
                'q2': 'd'
            },
            'wednesday': {
                'q1': 'd',
                'q2': 'c'
            },
            'thursday': {
                'q1': 'c',
                'q2': 'c'
            },
            'friday': {
                'q1': 'c',
                'q2': 'b'
            },
        },
        'week7': {
            'monday': {
                'q1': 'b',
            },
            'tuesday': {
                'q1': 'a',
            },
            'wednesday': {
                'q1': 'c',
            },
            'thursday': {
                'q1': 'b',
            },
            'friday': {
                'q1': 'b',
            },
        },
        'week8': {
            'monday': {
                'q1': 'c',
            },
            'tuesday': {
                'q1': 'b',
                'q2': 'b',
            },
            'wednesday': {
                'q1': 'a',
            },
            'thursday': {
                'q1': 'b',
            },
            'friday': {
                'q1': 'd',
            },
            'saturday': {
                'q1': 'b',
            },
        },
        'week9': {
            'tuesday': {
                'q1': 'b',
            },
            'friday': {
                'q1': 'b',
            },
        },
        'week10': {
            'monday': {
                'q1': 'b',
                'q2': 'c',
                'q3': 'b',
                'q4': 'a',
                'q5': 'c',
            },
            'wednesday': {
                'q1': 'c',
            },
            'thursday': {
                'q1': 'b',
            },
            'friday': {
                'q1': 'd',
            },
        },

        'week11': {
            'quiz1': {
                'q1': 'b',
                'q2': 'b',
                'q3': 'a',
                'q4': 'c',
                'q5': 'c'
            }
        }
    };

    function checkAnswer(weekId, dayName, questionName, selectedValue, feedbackElement) {
        feedbackElement.style.display = 'block';
        feedbackElement.classList.remove('correct', 'incorrect');
        const correctAnswer = answers[weekId]?.[dayName]?.[questionName];

        if (selectedValue === correctAnswer) {
            feedbackElement.textContent = 'Correct!';
            feedbackElement.classList.add('correct');
        } else {
            let correctDisplay = correctAnswer;
            if (correctAnswer && ['a', 'b', 'c', 'd'].includes(correctAnswer.toLowerCase())) {
                correctDisplay = `option ${correctAnswer.toUpperCase()}`;
            } else if (!correctAnswer) {
                correctDisplay = " (Answer not found in script, please check)";
            }
            feedbackElement.textContent = `Incorrect. The correct answer is ${correctDisplay}.`;
            feedbackElement.classList.add('incorrect');
        }
    }

    const quizOptions = document.querySelectorAll('.quiz-container .quiz-option');

    quizOptions.forEach(optionDiv => {
        optionDiv.addEventListener('click', (event) => {
            const clickedOption = event.target;
            const questionName = clickedOption.getAttribute('data-question');
            const selectedValue = clickedOption.getAttribute('data-value');

            const dayContentDiv = clickedOption.closest('.day-content');
            if (!dayContentDiv) {
                console.error("Clicked quiz option is not within a .day-content div.");
                return;
            }
            const dayContentId = dayContentDiv.id;
            const parts = dayContentId.split('-');
            const dayName = parts[0];
            const weekId = parts[2];

            const feedbackElement = clickedOption.closest('.question-block').querySelector('.quiz-feedback');
            if (!feedbackElement) {
                console.error("Quiz feedback element not found within the question block.");
                return;
            }

            clickedOption.closest('.options').querySelectorAll('.quiz-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            clickedOption.classList.add('selected');

            checkAnswer(weekId, dayName, questionName, selectedValue, feedbackElement);
        });
    });
});</script>
</body>
</html>

<!--<div id="saturday-content-week3" class="day-content day-section">
        <h2>Brain Cache</h2>
        <div class="content-block">
            <p>Week 3 Quiz coming soon!</p>
<p>Quiz answers will be uploaded soon!</p>
            <center><button onclick="window.location.href='https://thecodersclub-mce.github.io/dsa/quiz.html'">
    Week 3 Quiz
</button></center>
        </div>
    </div>-->
